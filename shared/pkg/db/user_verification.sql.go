// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_verification.sql

package db

import (
	"context"
	"database/sql"
)

const canResendVerificationCode = `-- name: CanResendVerificationCode :one
SELECT CASE
         WHEN last_sent_at IS NULL THEN TRUE
         WHEN now() - last_sent_at >= interval '1 minute' THEN TRUE
         ELSE FALSE
       END AS can_resend
FROM user_verifications
WHERE user_id = $1
  AND verified_at IS NULL
  AND is_expired = FALSE
  AND expires_at > now()
`

// -------------------------------
// 2a. Check if user can get a new verification code
// -------------------------------
func (q *Queries) CanResendVerificationCode(ctx context.Context, userID sql.NullInt64) (bool, error) {
	row := q.db.QueryRowContext(ctx, canResendVerificationCode, userID)
	var can_resend bool
	err := row.Scan(&can_resend)
	return can_resend, err
}

const expirePreviousUserVerification = `-- name: ExpirePreviousUserVerification :one
UPDATE user_verifications
SET is_expired = TRUE
WHERE user_id = $1
  AND verified_at IS NULL
  AND is_expired = FALSE
RETURNING id, user_id, verification_code, expires_at, created_at, failed_attempts, max_attempts, last_sent_at, verified_at, is_expired
`

// -------------------------------
// 6. Expire previous user verification
// -------------------------------
func (q *Queries) ExpirePreviousUserVerification(ctx context.Context, userID sql.NullInt64) (UserVerification, error) {
	row := q.db.QueryRowContext(ctx, expirePreviousUserVerification, userID)
	var i UserVerification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.VerificationCode,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.FailedAttempts,
		&i.MaxAttempts,
		&i.LastSentAt,
		&i.VerifiedAt,
		&i.IsExpired,
	)
	return i, err
}

const getActiveUserVerificationByUserID = `-- name: GetActiveUserVerificationByUserID :one
SELECT id, user_id, verification_code, expires_at, created_at, failed_attempts, max_attempts, last_sent_at, verified_at, is_expired
FROM user_verifications
WHERE user_id = $1
  AND verified_at IS NULL
  AND is_expired = FALSE
  AND expires_at > now()
`

// -------------------------------
// 2. Get active user verification by user ID
// -------------------------------
func (q *Queries) GetActiveUserVerificationByUserID(ctx context.Context, userID sql.NullInt64) (UserVerification, error) {
	row := q.db.QueryRowContext(ctx, getActiveUserVerificationByUserID, userID)
	var i UserVerification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.VerificationCode,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.FailedAttempts,
		&i.MaxAttempts,
		&i.LastSentAt,
		&i.VerifiedAt,
		&i.IsExpired,
	)
	return i, err
}

const incrementFailedAttemptsAndExpireIfMaxReached = `-- name: IncrementFailedAttemptsAndExpireIfMaxReached :one
UPDATE user_verifications
SET failed_attempts = failed_attempts + 1,
    is_expired = CASE
                   WHEN failed_attempts + 1 >= max_attempts THEN TRUE
                   ELSE is_expired
                 END
WHERE user_id = $1
  AND verified_at IS NULL
  AND is_expired = FALSE
  AND expires_at > now()
RETURNING id, user_id, verification_code, expires_at, created_at, failed_attempts, max_attempts, last_sent_at, verified_at, is_expired
`

// -------------------------------
// 4. Increment failed attempts and expire if max attempts reached
// -------------------------------
func (q *Queries) IncrementFailedAttemptsAndExpireIfMaxReached(ctx context.Context, userID sql.NullInt64) (UserVerification, error) {
	row := q.db.QueryRowContext(ctx, incrementFailedAttemptsAndExpireIfMaxReached, userID)
	var i UserVerification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.VerificationCode,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.FailedAttempts,
		&i.MaxAttempts,
		&i.LastSentAt,
		&i.VerifiedAt,
		&i.IsExpired,
	)
	return i, err
}

const insertUserVerification = `-- name: InsertUserVerification :one

INSERT INTO user_verifications (user_id, verification_code)
VALUES ($1, $2)
RETURNING id, user_id, verification_code, expires_at, created_at, failed_attempts, max_attempts, last_sent_at, verified_at, is_expired
`

type InsertUserVerificationParams struct {
	UserID           sql.NullInt64
	VerificationCode string
}

// --------------------------------------------------------
// SQL queries for user verification management
// --------------------------------------------------------
// -------------------------------
// 1. Insert a new user verification record
// -------------------------------
func (q *Queries) InsertUserVerification(ctx context.Context, arg InsertUserVerificationParams) (UserVerification, error) {
	row := q.db.QueryRowContext(ctx, insertUserVerification, arg.UserID, arg.VerificationCode)
	var i UserVerification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.VerificationCode,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.FailedAttempts,
		&i.MaxAttempts,
		&i.LastSentAt,
		&i.VerifiedAt,
		&i.IsExpired,
	)
	return i, err
}

const markVerificationAsVerified = `-- name: MarkVerificationAsVerified :one
UPDATE user_verifications
SET verified_at = now()
WHERE user_id = $1
  AND verification_code = $2
  AND verified_at IS NULL
  AND is_expired = FALSE
  AND expires_at > now()
RETURNING id, user_id, verification_code, expires_at, created_at, failed_attempts, max_attempts, last_sent_at, verified_at, is_expired
`

type MarkVerificationAsVerifiedParams struct {
	UserID           sql.NullInt64
	VerificationCode string
}

// -------------------------------
// 5. Mark verification as verified
// -------------------------------
func (q *Queries) MarkVerificationAsVerified(ctx context.Context, arg MarkVerificationAsVerifiedParams) (UserVerification, error) {
	row := q.db.QueryRowContext(ctx, markVerificationAsVerified, arg.UserID, arg.VerificationCode)
	var i UserVerification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.VerificationCode,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.FailedAttempts,
		&i.MaxAttempts,
		&i.LastSentAt,
		&i.VerifiedAt,
		&i.IsExpired,
	)
	return i, err
}

const updateUserVerificationCode = `-- name: UpdateUserVerificationCode :one
UPDATE user_verifications
SET verification_code = $2,
    expires_at = (now() + interval '24 hours'),
    last_sent_at = now(),
    failed_attempts = 0,
    is_expired = FALSE
WHERE user_id = $1
  AND verified_at IS NULL
RETURNING id, user_id, verification_code, expires_at, created_at, failed_attempts, max_attempts, last_sent_at, verified_at, is_expired
`

type UpdateUserVerificationCodeParams struct {
	UserID           sql.NullInt64
	VerificationCode string
}

// -------------------------------
// 3. Update verification code and reset failed attempts
// -------------------------------
func (q *Queries) UpdateUserVerificationCode(ctx context.Context, arg UpdateUserVerificationCodeParams) (UserVerification, error) {
	row := q.db.QueryRowContext(ctx, updateUserVerificationCode, arg.UserID, arg.VerificationCode)
	var i UserVerification
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.VerificationCode,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.FailedAttempts,
		&i.MaxAttempts,
		&i.LastSentAt,
		&i.VerifiedAt,
		&i.IsExpired,
	)
	return i, err
}
