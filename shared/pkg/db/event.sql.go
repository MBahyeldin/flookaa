// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: event.sql

package db

import (
	"context"

	"github.com/lib/pq"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
    name,
    action,
    target_id,
    target_type,
    owner,
    owner_id,
    actor_id
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, name, action, target_id, target_type, owner, owner_id, actor_id, created_at, updated_at, deleted_at
`

type CreateEventParams struct {
	Name       EventEnum
	Action     EventActionEnum
	TargetID   string
	TargetType EventTargetTypeEnum
	Owner      OwnerEnum
	OwnerID    int64
	ActorID    int64
}

// -------------------------------
// 1. Create a new Event
// -------------------------------
func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, createEvent,
		arg.Name,
		arg.Action,
		arg.TargetID,
		arg.TargetType,
		arg.Owner,
		arg.OwnerID,
		arg.ActorID,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Action,
		&i.TargetID,
		&i.TargetType,
		&i.Owner,
		&i.OwnerID,
		&i.ActorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getMetaFromEvents = `-- name: GetMetaFromEvents :many
SELECT
    name,
    target_id,
    COUNT(*) AS count
FROM events
WHERE name IN ('comment', 'like')
  AND target_id = $1
  AND deleted_at IS NULL
GROUP BY name, target_id
`

type GetMetaFromEventsRow struct {
	Name     EventEnum
	TargetID string
	Count    int64
}

// -------------------------------
// 2.1 Get events comments and likes per post
// -------------------------------
func (q *Queries) GetMetaFromEvents(ctx context.Context, targetID string) ([]GetMetaFromEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMetaFromEvents, targetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMetaFromEventsRow
	for rows.Next() {
		var i GetMetaFromEventsRow
		if err := rows.Scan(&i.Name, &i.TargetID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPersonaActivities = `-- name: GetPersonaActivities :many
SELECT
  actor_id,
  ARRAY(
    SELECT target_id
    FROM events e2
    WHERE e2.actor_id = e.actor_id AND e2.name = 'comment'
    ORDER BY e2.created_at DESC
    LIMIT 1000
  ) AS comment_targets,
  ARRAY(
    SELECT target_id
    FROM events e2
    WHERE e2.actor_id = e.actor_id AND e2.name = 'post'
    ORDER BY e2.created_at DESC
    LIMIT 1000
  ) AS post_targets,
  ARRAY(
    SELECT target_id
    FROM events e2
    WHERE e2.actor_id = e.actor_id AND e2.name = 'like'
    ORDER BY e2.created_at DESC
    LIMIT 1000
  ) AS like_targets
FROM events e
WHERE e.actor_id = $1
GROUP BY actor_id
`

type GetPersonaActivitiesRow struct {
	ActorID        int64
	CommentTargets []string
	PostTargets    []string
	LikeTargets    []string
}

// -------------------------------
// 3. Get user activities (events)
// -------------------------------
func (q *Queries) GetPersonaActivities(ctx context.Context, actorID int64) ([]GetPersonaActivitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPersonaActivities, actorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPersonaActivitiesRow
	for rows.Next() {
		var i GetPersonaActivitiesRow
		if err := rows.Scan(
			&i.ActorID,
			pq.Array(&i.CommentTargets),
			pq.Array(&i.PostTargets),
			pq.Array(&i.LikeTargets),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isUserLikedTarget = `-- name: IsUserLikedTarget :one
SELECT
    COUNT(*) > 0 AS liked
FROM events
WHERE name = 'like'
  AND target_id = $1
  AND actor_id = $2
  AND deleted_at IS NULL
`

type IsUserLikedTargetParams struct {
	TargetID string
	ActorID  int64
}

// ------------------------------
// 5. is user liked a target
// ------------------------------
func (q *Queries) IsUserLikedTarget(ctx context.Context, arg IsUserLikedTargetParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isUserLikedTarget, arg.TargetID, arg.ActorID)
	var liked bool
	err := row.Scan(&liked)
	return liked, err
}

const unlikeEvent = `-- name: UnlikeEvent :exec
UPDATE events
SET deleted_at = NOW(), updated_at = NOW()
WHERE name = 'like'
  AND target_id = $1
  AND actor_id = $2
  AND deleted_at IS NULL
`

type UnlikeEventParams struct {
	TargetID string
	ActorID  int64
}

// ------------------------------
// 6. Unlike (soft delete) a like event
// ------------------------------
func (q *Queries) UnlikeEvent(ctx context.Context, arg UnlikeEventParams) error {
	_, err := q.db.ExecContext(ctx, unlikeEvent, arg.TargetID, arg.ActorID)
	return err
}
