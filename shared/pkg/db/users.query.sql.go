// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.query.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (first_name, last_name, phone, email_address, hashed_password, oauth_provider, thumbnail, is_verified, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW())
RETURNING id, uuid, first_name, last_name, phone, email_address, created_at, updated_at, deleted_at, hashed_password, thumbnail, is_verified, bio, postal_code, other_platforms_accounts, country_id, state_id, city_id, oauth_provider
`

type CreateUserParams struct {
	FirstName      string
	LastName       string
	Phone          string
	EmailAddress   string
	HashedPassword sql.NullString
	OauthProvider  NullOauthProvider
	Thumbnail      sql.NullString
	IsVerified     sql.NullBool
}

// -------------------------------
// 1. Create a new user
// -------------------------------
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.FirstName,
		arg.LastName,
		arg.Phone,
		arg.EmailAddress,
		arg.HashedPassword,
		arg.OauthProvider,
		arg.Thumbnail,
		arg.IsVerified,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.EmailAddress,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.HashedPassword,
		&i.Thumbnail,
		&i.IsVerified,
		&i.Bio,
		&i.PostalCode,
		pq.Array(&i.OtherPlatformsAccounts),
		&i.CountryID,
		&i.StateID,
		&i.CityID,
		&i.OauthProvider,
	)
	return i, err
}

const getUserBasicInfo = `-- name: GetUserBasicInfo :one
SELECT u.id, u.first_name, u.last_name, u.email_address, u.is_verified, u.thumbnail,
        (SELECT COALESCE(json_agg(json_build_object(
               'id', c.id,
               'name', c.name,
               'description', c.description,
               'created_at', c.created_at
           )), '[]'::json)
           FROM channel_members cm
           JOIN channels c ON c.id = cm.channel_id
           WHERE cm.user_id = u.id AND cm.left_at IS NULL
       ) AS joined_channels,
        (SELECT COALESCE(json_agg(json_build_object(
               'id', c.id,
               'name', c.name,
               'description', c.description,
               'created_at', c.created_at
           )), '[]'::json)
           FROM channel_followers cm
           JOIN channels c ON c.id = cm.channel_id
           WHERE cm.user_id = u.id AND cm.unfollowed_at IS NULL
       ) AS followed_channels
FROM users u
WHERE u.id = $1
  AND u.deleted_at IS NULL
`

type GetUserBasicInfoRow struct {
	ID               int64
	FirstName        string
	LastName         string
	EmailAddress     string
	IsVerified       sql.NullBool
	Thumbnail        sql.NullString
	JoinedChannels   pqtype.NullRawMessage
	FollowedChannels pqtype.NullRawMessage
}

// -------------------------------
// 7. Get user Basic Info
// -------------------------------
func (q *Queries) GetUserBasicInfo(ctx context.Context, id int64) (GetUserBasicInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getUserBasicInfo, id)
	var i GetUserBasicInfoRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.EmailAddress,
		&i.IsVerified,
		&i.Thumbnail,
		&i.JoinedChannels,
		&i.FollowedChannels,
	)
	return i, err
}

const getUserByEmailAddress = `-- name: GetUserByEmailAddress :one
SELECT id, uuid, first_name, last_name, phone, email_address, created_at, updated_at, deleted_at, hashed_password, thumbnail, is_verified, bio, postal_code, other_platforms_accounts, country_id, state_id, city_id, oauth_provider FROM users WHERE email_address = $1 AND deleted_at IS NULL LIMIT 1
`

// -------------------------------
// 2.1 Get User by email and provider
// -------------------------------
func (q *Queries) GetUserByEmailAddress(ctx context.Context, emailAddress string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmailAddress, emailAddress)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.EmailAddress,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.HashedPassword,
		&i.Thumbnail,
		&i.IsVerified,
		&i.Bio,
		&i.PostalCode,
		pq.Array(&i.OtherPlatformsAccounts),
		&i.CountryID,
		&i.StateID,
		&i.CityID,
		&i.OauthProvider,
	)
	return i, err
}

const getUserFollowedChannels = `-- name: GetUserFollowedChannels :many
SELECT c.id, c.name, c.description, c.thumbnail, c.banner, c.owner_id, c.created_at, c.updated_at, c.deleted_at
FROM channel_followers cf
JOIN channels c ON cf.channel_id = c.id
WHERE cf.user_id = $1
  AND cf.unfollowed_at IS NULL
`

// -------------------------------
// 10. Get channels a user follows
// -------------------------------
func (q *Queries) GetUserFollowedChannels(ctx context.Context, userID int64) ([]Channel, error) {
	rows, err := q.db.QueryContext(ctx, getUserFollowedChannels, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Channel
	for rows.Next() {
		var i Channel
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Thumbnail,
			&i.Banner,
			&i.OwnerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserHashedPasswordByEmail = `-- name: GetUserHashedPasswordByEmail :one
SELECT id, email_address, hashed_password FROM users WHERE email_address = $1 LIMIT 1
`

type GetUserHashedPasswordByEmailRow struct {
	ID             int64
	EmailAddress   string
	HashedPassword sql.NullString
}

// -------------------------------
// 2.0 Get User HashedPassword by email for authentication
// -------------------------------
func (q *Queries) GetUserHashedPasswordByEmail(ctx context.Context, emailAddress string) (GetUserHashedPasswordByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserHashedPasswordByEmail, emailAddress)
	var i GetUserHashedPasswordByEmailRow
	err := row.Scan(&i.ID, &i.EmailAddress, &i.HashedPassword)
	return i, err
}

const getUserJoinedChannels = `-- name: GetUserJoinedChannels :many
SELECT c.id, c.name, c.description, c.thumbnail, c.banner, c.owner_id, c.created_at, c.updated_at, c.deleted_at
FROM channel_members cm
JOIN channels c ON cm.channel_id = c.id
WHERE cm.user_id = $1
  AND cm.left_at IS NULL
`

// -------------------------------
// 9. Get channels a user has joined
// -------------------------------
func (q *Queries) GetUserJoinedChannels(ctx context.Context, userID int64) ([]Channel, error) {
	rows, err := q.db.QueryContext(ctx, getUserJoinedChannels, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Channel
	for rows.Next() {
		var i Channel
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Thumbnail,
			&i.Banner,
			&i.OwnerID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserProfile = `-- name: GetUserProfile :one
SELECT u.id, u.uuid, u.first_name, u.last_name, u.phone, u.email_address, u.created_at, u.updated_at, u.deleted_at, u.hashed_password, u.thumbnail, u.is_verified, u.bio, u.postal_code, u.other_platforms_accounts, u.country_id, u.state_id, u.city_id, u.oauth_provider,
        (SELECT COALESCE(json_agg(json_build_object(
               'id', c.id,
               'name', c.name,
               'description', c.description,
               'created_at', c.created_at
           )), '[]'::json)
           FROM channel_members cm
           JOIN channels c ON c.id = cm.channel_id
           WHERE cm.user_id = u.id AND cm.left_at IS NULL
       ) AS joined_channels,
        (SELECT COALESCE(json_agg(json_build_object(
               'id', c.id,
               'name', c.name,
               'description', c.description,
               'created_at', c.created_at
           )), '[]'::json)
           FROM channel_followers cm
           JOIN channels c ON c.id = cm.channel_id
           WHERE cm.user_id = u.id AND cm.unfollowed_at IS NULL
       ) AS followed_channels
FROM users u
WHERE u.id = $1
  AND u.deleted_at IS NULL
`

type GetUserProfileRow struct {
	ID                     int64
	Uuid                   uuid.NullUUID
	FirstName              string
	LastName               string
	Phone                  string
	EmailAddress           string
	CreatedAt              time.Time
	UpdatedAt              time.Time
	DeletedAt              sql.NullTime
	HashedPassword         sql.NullString
	Thumbnail              sql.NullString
	IsVerified             sql.NullBool
	Bio                    sql.NullString
	PostalCode             sql.NullString
	OtherPlatformsAccounts []string
	CountryID              sql.NullInt64
	StateID                sql.NullInt64
	CityID                 sql.NullInt64
	OauthProvider          NullOauthProvider
	JoinedChannels         pqtype.NullRawMessage
	FollowedChannels       pqtype.NullRawMessage
}

// -------------------------------
// 7. Get user profile
// -------------------------------
func (q *Queries) GetUserProfile(ctx context.Context, id int64) (GetUserProfileRow, error) {
	row := q.db.QueryRowContext(ctx, getUserProfile, id)
	var i GetUserProfileRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.EmailAddress,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.HashedPassword,
		&i.Thumbnail,
		&i.IsVerified,
		&i.Bio,
		&i.PostalCode,
		pq.Array(&i.OtherPlatformsAccounts),
		&i.CountryID,
		&i.StateID,
		&i.CityID,
		&i.OauthProvider,
		&i.JoinedChannels,
		&i.FollowedChannels,
	)
	return i, err
}

const getUserStats = `-- name: GetUserStats :one
SELECT u.id,
       (SELECT COUNT(*) FROM channel_members cm WHERE cm.user_id = u.id AND cm.left_at IS NULL) AS channels_joined,
       (SELECT COUNT(*) FROM channel_followers cf WHERE cf.user_id = u.id AND cf.unfollowed_at IS NULL) AS channels_followed,
       (SELECT COUNT(*) FROM post_references pr WHERE pr.owner_type = 'user' AND pr.owner_id = u.id) AS posts_count
FROM users u
WHERE u.id = $1
  AND u.deleted_at IS NULL
`

type GetUserStatsRow struct {
	ID               int64
	ChannelsJoined   int64
	ChannelsFollowed int64
	PostsCount       int64
}

// -------------------------------
// 8. Get user stats
// -------------------------------
func (q *Queries) GetUserStats(ctx context.Context, id int64) (GetUserStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getUserStats, id)
	var i GetUserStatsRow
	err := row.Scan(
		&i.ID,
		&i.ChannelsJoined,
		&i.ChannelsFollowed,
		&i.PostsCount,
	)
	return i, err
}

const resetUserPassword = `-- name: ResetUserPassword :one
UPDATE users
SET hashed_password = $1,
    updated_at = NOW()
WHERE id = $2
RETURNING id, uuid, first_name, last_name, phone, email_address, created_at, updated_at, deleted_at, hashed_password, thumbnail, is_verified, bio, postal_code, other_platforms_accounts, country_id, state_id, city_id, oauth_provider
`

type ResetUserPasswordParams struct {
	HashedPassword sql.NullString
	ID             int64
}

// -------------------------------
// 5. Reset user password
// -------------------------------
func (q *Queries) ResetUserPassword(ctx context.Context, arg ResetUserPasswordParams) (User, error) {
	row := q.db.QueryRowContext(ctx, resetUserPassword, arg.HashedPassword, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.EmailAddress,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.HashedPassword,
		&i.Thumbnail,
		&i.IsVerified,
		&i.Bio,
		&i.PostalCode,
		pq.Array(&i.OtherPlatformsAccounts),
		&i.CountryID,
		&i.StateID,
		&i.CityID,
		&i.OauthProvider,
	)
	return i, err
}

const resolveUserByID = `-- name: ResolveUserByID :one
SELECT id, first_name, last_name, email_address, thumbnail 
FROM users 
WHERE id = $1 
AND deleted_at IS NULL LIMIT 1
`

type ResolveUserByIDRow struct {
	ID           int64
	FirstName    string
	LastName     string
	EmailAddress string
	Thumbnail    sql.NullString
}

// -------------------------------
// 12. Resolve User By ID
// -------------------------------
func (q *Queries) ResolveUserByID(ctx context.Context, id int64) (ResolveUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, resolveUserByID, id)
	var i ResolveUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.EmailAddress,
		&i.Thumbnail,
	)
	return i, err
}

const searchUsersByName = `-- name: SearchUsersByName :many
SELECT id, uuid, first_name, last_name, phone, email_address, created_at, updated_at, deleted_at, hashed_password, thumbnail, is_verified, bio, postal_code, other_platforms_accounts, country_id, state_id, city_id, oauth_provider
FROM users
WHERE (first_name ILIKE '%' || $1 || '%'
       OR last_name ILIKE '%' || $1 || '%')
  AND deleted_at IS NULL
ORDER BY first_name, last_name
LIMIT $2 OFFSET $3
`

type SearchUsersByNameParams struct {
	Column1 sql.NullString
	Limit   int64
	Offset  int64
}

// -------------------------------
// 6. Search users by name
// -------------------------------
func (q *Queries) SearchUsersByName(ctx context.Context, arg SearchUsersByNameParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, searchUsersByName, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.FirstName,
			&i.LastName,
			&i.Phone,
			&i.EmailAddress,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.HashedPassword,
			&i.Thumbnail,
			&i.IsVerified,
			&i.Bio,
			&i.PostalCode,
			pq.Array(&i.OtherPlatformsAccounts),
			&i.CountryID,
			&i.StateID,
			&i.CityID,
			&i.OauthProvider,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET 
    first_name = COALESCE($1, first_name),
    last_name = COALESCE($2, last_name),
    phone = COALESCE($3, phone),
    email_address = COALESCE($4, email_address),
    hashed_password = COALESCE($5, hashed_password),
    thumbnail = COALESCE($6, thumbnail),
    is_verified = COALESCE($7, is_verified),
    bio = COALESCE($8, bio),
    city_id = COALESCE($9, city_id),
    country_id = COALESCE($10, country_id),
    state_id = COALESCE($11, state_id),
    postal_code = COALESCE($12, postal_code),
    other_platforms_accounts = COALESCE($13, other_platforms_accounts),
    updated_at = now()
WHERE id = $14
RETURNING 
    id,
    first_name,
    last_name,
    phone,
    email_address,
    updated_at,
    thumbnail,
    is_verified,
    bio,
    city_id,
    state_id,
    country_id,
    postal_code,
    other_platforms_accounts
`

type UpdateUserParams struct {
	FirstName              string
	LastName               string
	Phone                  string
	EmailAddress           string
	HashedPassword         sql.NullString
	Thumbnail              sql.NullString
	IsVerified             sql.NullBool
	Bio                    sql.NullString
	CityID                 sql.NullInt64
	CountryID              sql.NullInt64
	StateID                sql.NullInt64
	PostalCode             sql.NullString
	OtherPlatformsAccounts []string
	ID                     int64
}

type UpdateUserRow struct {
	ID                     int64
	FirstName              string
	LastName               string
	Phone                  string
	EmailAddress           string
	UpdatedAt              time.Time
	Thumbnail              sql.NullString
	IsVerified             sql.NullBool
	Bio                    sql.NullString
	CityID                 sql.NullInt64
	StateID                sql.NullInt64
	CountryID              sql.NullInt64
	PostalCode             sql.NullString
	OtherPlatformsAccounts []string
}

// -------------------------------
// 3. Update user details
// -------------------------------
func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (UpdateUserRow, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.FirstName,
		arg.LastName,
		arg.Phone,
		arg.EmailAddress,
		arg.HashedPassword,
		arg.Thumbnail,
		arg.IsVerified,
		arg.Bio,
		arg.CityID,
		arg.CountryID,
		arg.StateID,
		arg.PostalCode,
		pq.Array(arg.OtherPlatformsAccounts),
		arg.ID,
	)
	var i UpdateUserRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.EmailAddress,
		&i.UpdatedAt,
		&i.Thumbnail,
		&i.IsVerified,
		&i.Bio,
		&i.CityID,
		&i.StateID,
		&i.CountryID,
		&i.PostalCode,
		pq.Array(&i.OtherPlatformsAccounts),
	)
	return i, err
}

const verifyUserEmail = `-- name: VerifyUserEmail :one
UPDATE users
SET is_verified = TRUE,
    updated_at = NOW()
WHERE id = $1
RETURNING id, uuid, first_name, last_name, phone, email_address, created_at, updated_at, deleted_at, hashed_password, thumbnail, is_verified, bio, postal_code, other_platforms_accounts, country_id, state_id, city_id, oauth_provider
`

// -------------------------------
// 4. Verify user email
// -------------------------------
func (q *Queries) VerifyUserEmail(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, verifyUserEmail, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.EmailAddress,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.HashedPassword,
		&i.Thumbnail,
		&i.IsVerified,
		&i.Bio,
		&i.PostalCode,
		pq.Array(&i.OtherPlatformsAccounts),
		&i.CountryID,
		&i.StateID,
		&i.CityID,
		&i.OauthProvider,
	)
	return i, err
}
