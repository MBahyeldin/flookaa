// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"context"
	"errors"
	"fmt"
	"shared/pkg/graph/models"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _BlockBlock__type(ctx context.Context, field graphql.CollectedField, obj *models.BlockBlock) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BlockBlock__type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNBlockType2sharedᚋpkgᚋgraphᚋmodelsᚐBlockType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BlockBlock__type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BlockType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockBlock__key(ctx context.Context, field graphql.CollectedField, obj *models.BlockBlock) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BlockBlock__key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BlockBlock__key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockBlock_style(ctx context.Context, field graphql.CollectedField, obj *models.BlockBlock) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BlockBlock_style,
		func(ctx context.Context) (any, error) {
			return obj.Style, nil
		},
		nil,
		ec.marshalNStyleType2sharedᚋpkgᚋgraphᚋmodelsᚐStyleType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BlockBlock_style(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StyleType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockBlock_children(ctx context.Context, field graphql.CollectedField, obj *models.BlockBlock) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BlockBlock_children,
		func(ctx context.Context) (any, error) {
			return obj.Children, nil
		},
		nil,
		ec.marshalNSpan2ᚕᚖsharedᚋpkgᚋgraphᚋmodelsᚐSpanᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BlockBlock_children(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_type":
				return ec.fieldContext_Span__type(ctx, field)
			case "_key":
				return ec.fieldContext_Span__key(ctx, field)
			case "text":
				return ec.fieldContext_Span_text(ctx, field)
			case "marks":
				return ec.fieldContext_Span_marks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Span", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockBlock_markDefs(ctx context.Context, field graphql.CollectedField, obj *models.BlockBlock) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BlockBlock_markDefs,
		func(ctx context.Context) (any, error) {
			return obj.MarkDefs, nil
		},
		nil,
		ec.marshalNMarkDefs2ᚕᚖsharedᚋpkgᚋgraphᚋmodelsᚐMarkDefsᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BlockBlock_markDefs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "link":
				return ec.fieldContext_MarkDefs_link(ctx, field)
			case "comment":
				return ec.fieldContext_MarkDefs_comment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MarkDefs", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockBlock_listItem(ctx context.Context, field graphql.CollectedField, obj *models.BlockBlock) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BlockBlock_listItem,
		func(ctx context.Context) (any, error) {
			return obj.ListItem, nil
		},
		nil,
		ec.marshalOListItemType2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐListItemType,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BlockBlock_listItem(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ListItemType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BlockBlock_level(ctx context.Context, field graphql.CollectedField, obj *models.BlockBlock) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BlockBlock_level,
		func(ctx context.Context) (any, error) {
			return obj.Level, nil
		},
		nil,
		ec.marshalOInt2ᚖint32,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_BlockBlock_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BlockBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Blocks_block(ctx context.Context, field graphql.CollectedField, obj *models.Blocks) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Blocks_block,
		func(ctx context.Context) (any, error) {
			return obj.Block, nil
		},
		nil,
		ec.marshalOBlockBlock2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐBlockBlock,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Blocks_block(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Blocks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_type":
				return ec.fieldContext_BlockBlock__type(ctx, field)
			case "_key":
				return ec.fieldContext_BlockBlock__key(ctx, field)
			case "style":
				return ec.fieldContext_BlockBlock_style(ctx, field)
			case "children":
				return ec.fieldContext_BlockBlock_children(ctx, field)
			case "markDefs":
				return ec.fieldContext_BlockBlock_markDefs(ctx, field)
			case "listItem":
				return ec.fieldContext_BlockBlock_listItem(ctx, field)
			case "level":
				return ec.fieldContext_BlockBlock_level(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BlockBlock", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Blocks_image(ctx context.Context, field graphql.CollectedField, obj *models.Blocks) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Blocks_image,
		func(ctx context.Context) (any, error) {
			return obj.Image, nil
		},
		nil,
		ec.marshalOImageBlock2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐImageBlock,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Blocks_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Blocks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_type":
				return ec.fieldContext_ImageBlock__type(ctx, field)
			case "_key":
				return ec.fieldContext_ImageBlock__key(ctx, field)
			case "src":
				return ec.fieldContext_ImageBlock_src(ctx, field)
			case "alt":
				return ec.fieldContext_ImageBlock_alt(ctx, field)
			case "caption":
				return ec.fieldContext_ImageBlock_caption(ctx, field)
			case "width":
				return ec.fieldContext_ImageBlock_width(ctx, field)
			case "height":
				return ec.fieldContext_ImageBlock_height(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageBlock", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Blocks_break(ctx context.Context, field graphql.CollectedField, obj *models.Blocks) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Blocks_break,
		func(ctx context.Context) (any, error) {
			return obj.Break, nil
		},
		nil,
		ec.marshalOBreakBlock2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐBreakBlock,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Blocks_break(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Blocks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_type":
				return ec.fieldContext_BreakBlock__type(ctx, field)
			case "_key":
				return ec.fieldContext_BreakBlock__key(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BreakBlock", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BreakBlock__type(ctx context.Context, field graphql.CollectedField, obj *models.BreakBlock) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BreakBlock__type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNBlockType2sharedᚋpkgᚋgraphᚋmodelsᚐBlockType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BreakBlock__type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BreakBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BlockType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BreakBlock__key(ctx context.Context, field graphql.CollectedField, obj *models.BreakBlock) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_BreakBlock__key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_BreakBlock__key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BreakBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommentMarkDef__key(ctx context.Context, field graphql.CollectedField, obj *models.CommentMarkDef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CommentMarkDef__key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CommentMarkDef__key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommentMarkDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommentMarkDef__type(ctx context.Context, field graphql.CollectedField, obj *models.CommentMarkDef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CommentMarkDef__type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNMarkDefType2sharedᚋpkgᚋgraphᚋmodelsᚐMarkDefType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CommentMarkDef__type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommentMarkDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MarkDefType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommentMarkDef_text(ctx context.Context, field graphql.CollectedField, obj *models.CommentMarkDef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_CommentMarkDef_text,
		func(ctx context.Context) (any, error) {
			return obj.Text, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_CommentMarkDef_text(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommentMarkDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageBlock__type(ctx context.Context, field graphql.CollectedField, obj *models.ImageBlock) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageBlock__type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNBlockType2sharedᚋpkgᚋgraphᚋmodelsᚐBlockType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageBlock__type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BlockType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageBlock__key(ctx context.Context, field graphql.CollectedField, obj *models.ImageBlock) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageBlock__key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageBlock__key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageBlock_src(ctx context.Context, field graphql.CollectedField, obj *models.ImageBlock) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageBlock_src,
		func(ctx context.Context) (any, error) {
			return obj.Src, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ImageBlock_src(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageBlock_alt(ctx context.Context, field graphql.CollectedField, obj *models.ImageBlock) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageBlock_alt,
		func(ctx context.Context) (any, error) {
			return obj.Alt, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ImageBlock_alt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageBlock_caption(ctx context.Context, field graphql.CollectedField, obj *models.ImageBlock) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageBlock_caption,
		func(ctx context.Context) (any, error) {
			return obj.Caption, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ImageBlock_caption(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageBlock_width(ctx context.Context, field graphql.CollectedField, obj *models.ImageBlock) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageBlock_width,
		func(ctx context.Context) (any, error) {
			return obj.Width, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ImageBlock_width(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageBlock_height(ctx context.Context, field graphql.CollectedField, obj *models.ImageBlock) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ImageBlock_height,
		func(ctx context.Context) (any, error) {
			return obj.Height, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_ImageBlock_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LinkMarkDef__key(ctx context.Context, field graphql.CollectedField, obj *models.LinkMarkDef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LinkMarkDef__key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LinkMarkDef__key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LinkMarkDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LinkMarkDef__type(ctx context.Context, field graphql.CollectedField, obj *models.LinkMarkDef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LinkMarkDef__type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNMarkDefType2sharedᚋpkgᚋgraphᚋmodelsᚐMarkDefType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LinkMarkDef__type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LinkMarkDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MarkDefType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LinkMarkDef_href(ctx context.Context, field graphql.CollectedField, obj *models.LinkMarkDef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LinkMarkDef_href,
		func(ctx context.Context) (any, error) {
			return obj.Href, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_LinkMarkDef_href(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LinkMarkDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LinkMarkDef_title(ctx context.Context, field graphql.CollectedField, obj *models.LinkMarkDef) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_LinkMarkDef_title,
		func(ctx context.Context) (any, error) {
			return obj.Title, nil
		},
		nil,
		ec.marshalOString2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_LinkMarkDef_title(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LinkMarkDef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarkDefs_link(ctx context.Context, field graphql.CollectedField, obj *models.MarkDefs) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_MarkDefs_link,
		func(ctx context.Context) (any, error) {
			return obj.Link, nil
		},
		nil,
		ec.marshalOLinkMarkDef2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐLinkMarkDef,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_MarkDefs_link(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarkDefs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_key":
				return ec.fieldContext_LinkMarkDef__key(ctx, field)
			case "_type":
				return ec.fieldContext_LinkMarkDef__type(ctx, field)
			case "href":
				return ec.fieldContext_LinkMarkDef_href(ctx, field)
			case "title":
				return ec.fieldContext_LinkMarkDef_title(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LinkMarkDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MarkDefs_comment(ctx context.Context, field graphql.CollectedField, obj *models.MarkDefs) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_MarkDefs_comment,
		func(ctx context.Context) (any, error) {
			return obj.Comment, nil
		},
		nil,
		ec.marshalOCommentMarkDef2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐCommentMarkDef,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_MarkDefs_comment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MarkDefs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "_key":
				return ec.fieldContext_CommentMarkDef__key(ctx, field)
			case "_type":
				return ec.fieldContext_CommentMarkDef__type(ctx, field)
			case "text":
				return ec.fieldContext_CommentMarkDef_text(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CommentMarkDef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PortableText_blocks(ctx context.Context, field graphql.CollectedField, obj *models.PortableText) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PortableText_blocks,
		func(ctx context.Context) (any, error) {
			return obj.Blocks, nil
		},
		nil,
		ec.marshalNBlocks2ᚕᚖsharedᚋpkgᚋgraphᚋmodelsᚐBlocksᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PortableText_blocks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PortableText",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "block":
				return ec.fieldContext_Blocks_block(ctx, field)
			case "image":
				return ec.fieldContext_Blocks_image(ctx, field)
			case "break":
				return ec.fieldContext_Blocks_break(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Blocks", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Span__type(ctx context.Context, field graphql.CollectedField, obj *models.Span) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Span__type,
		func(ctx context.Context) (any, error) {
			return obj.Type, nil
		},
		nil,
		ec.marshalNSpanType2sharedᚋpkgᚋgraphᚋmodelsᚐSpanType,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Span__type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Span",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SpanType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Span__key(ctx context.Context, field graphql.CollectedField, obj *models.Span) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Span__key,
		func(ctx context.Context) (any, error) {
			return obj.Key, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Span__key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Span",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Span_text(ctx context.Context, field graphql.CollectedField, obj *models.Span) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Span_text,
		func(ctx context.Context) (any, error) {
			return obj.Text, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Span_text(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Span",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Span_marks(ctx context.Context, field graphql.CollectedField, obj *models.Span) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Span_marks,
		func(ctx context.Context) (any, error) {
			return obj.Marks, nil
		},
		nil,
		ec.marshalNString2ᚕstringᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Span_marks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Span",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputBlockBlockInput(ctx context.Context, obj any) (models.BlockBlockInput, error) {
	var it models.BlockBlockInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_type", "_key", "style", "children", "markDefs", "listItem", "level"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_type"))
			data, err := ec.unmarshalNBlockType2sharedᚋpkgᚋgraphᚋmodelsᚐBlockType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "_key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_key"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "style":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("style"))
			data, err := ec.unmarshalNStyleType2sharedᚋpkgᚋgraphᚋmodelsᚐStyleType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Style = data
		case "children":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("children"))
			data, err := ec.unmarshalNSpanInput2ᚕᚖsharedᚋpkgᚋgraphᚋmodelsᚐSpanInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Children = data
		case "markDefs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("markDefs"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNMarkDefInput2ᚕᚖsharedᚋpkgᚋgraphᚋmodelsᚐMarkDefInputᚄ(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.Oneof == nil {
					var zeroVal []*models.MarkDefInput
					return zeroVal, errors.New("directive oneof is not implemented")
				}
				return ec.directives.Oneof(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*models.MarkDefInput); ok {
				it.MarkDefs = data
			} else if tmp == nil {
				it.MarkDefs = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*shared/pkg/graph/models.MarkDefInput`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "listItem":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("listItem"))
			data, err := ec.unmarshalOListItemType2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐListItemType(ctx, v)
			if err != nil {
				return it, err
			}
			it.ListItem = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBlockInput(ctx context.Context, obj any) (models.BlockInput, error) {
	var it models.BlockInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"block", "image", "break"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "block":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("block"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOBlockBlockInput2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐBlockBlockInput(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.Oneof == nil {
					var zeroVal *models.BlockBlockInput
					return zeroVal, errors.New("directive oneof is not implemented")
				}
				return ec.directives.Oneof(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*models.BlockBlockInput); ok {
				it.Block = data
			} else if tmp == nil {
				it.Block = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *shared/pkg/graph/models.BlockBlockInput`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "image":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("image"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOImageBlockInput2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐImageBlockInput(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.Oneof == nil {
					var zeroVal *models.ImageBlockInput
					return zeroVal, errors.New("directive oneof is not implemented")
				}
				return ec.directives.Oneof(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*models.ImageBlockInput); ok {
				it.Image = data
			} else if tmp == nil {
				it.Image = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *shared/pkg/graph/models.ImageBlockInput`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "break":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("break"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOBreakBlockInput2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐBreakBlockInput(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.Oneof == nil {
					var zeroVal *models.BreakBlockInput
					return zeroVal, errors.New("directive oneof is not implemented")
				}
				return ec.directives.Oneof(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*models.BreakBlockInput); ok {
				it.Break = data
			} else if tmp == nil {
				it.Break = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *shared/pkg/graph/models.BreakBlockInput`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBreakBlockInput(ctx context.Context, obj any) (models.BreakBlockInput, error) {
	var it models.BreakBlockInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_type", "_key"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_type"))
			data, err := ec.unmarshalNBlockType2sharedᚋpkgᚋgraphᚋmodelsᚐBlockType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "_key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_key"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCommentMarkDefInput(ctx context.Context, obj any) (models.CommentMarkDefInput, error) {
	var it models.CommentMarkDefInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_key", "_type", "text"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_key"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_type"))
			data, err := ec.unmarshalNMarkDefType2sharedᚋpkgᚋgraphᚋmodelsᚐMarkDefType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "text":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Text = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputImageBlockInput(ctx context.Context, obj any) (models.ImageBlockInput, error) {
	var it models.ImageBlockInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_type", "_key", "src", "alt", "caption", "width", "height"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_type"))
			data, err := ec.unmarshalNBlockType2sharedᚋpkgᚋgraphᚋmodelsᚐBlockType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "_key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_key"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "src":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("src"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Src = data
		case "alt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alt"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alt = data
		case "caption":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("caption"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Caption = data
		case "width":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("width"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Width = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLinkMarkDefInput(ctx context.Context, obj any) (models.LinkMarkDefInput, error) {
	var it models.LinkMarkDefInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_key", "_type", "href", "title"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_key"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_type"))
			data, err := ec.unmarshalNMarkDefType2sharedᚋpkgᚋgraphᚋmodelsᚐMarkDefType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "href":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("href"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Href = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMarkDefInput(ctx context.Context, obj any) (models.MarkDefInput, error) {
	var it models.MarkDefInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"link", "comment"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "link":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("link"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOLinkMarkDefInput2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐLinkMarkDefInput(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.Oneof == nil {
					var zeroVal *models.LinkMarkDefInput
					return zeroVal, errors.New("directive oneof is not implemented")
				}
				return ec.directives.Oneof(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*models.LinkMarkDefInput); ok {
				it.Link = data
			} else if tmp == nil {
				it.Link = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *shared/pkg/graph/models.LinkMarkDefInput`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "comment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comment"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOCommentMarkDefInput2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐCommentMarkDefInput(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.Oneof == nil {
					var zeroVal *models.CommentMarkDefInput
					return zeroVal, errors.New("directive oneof is not implemented")
				}
				return ec.directives.Oneof(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*models.CommentMarkDefInput); ok {
				it.Comment = data
			} else if tmp == nil {
				it.Comment = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *shared/pkg/graph/models.CommentMarkDefInput`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPortableTextInput(ctx context.Context, obj any) (models.PortableTextInput, error) {
	var it models.PortableTextInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"blocks"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "blocks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blocks"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalNBlockInput2ᚕᚖsharedᚋpkgᚋgraphᚋmodelsᚐBlockInputᚄ(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.Oneof == nil {
					var zeroVal []*models.BlockInput
					return zeroVal, errors.New("directive oneof is not implemented")
				}
				return ec.directives.Oneof(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.([]*models.BlockInput); ok {
				it.Blocks = data
			} else if tmp == nil {
				it.Blocks = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be []*shared/pkg/graph/models.BlockInput`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSpanInput(ctx context.Context, obj any) (models.SpanInput, error) {
	var it models.SpanInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"_type", "_key", "text", "marks"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_type"))
			data, err := ec.unmarshalNSpanType2sharedᚋpkgᚋgraphᚋmodelsᚐSpanType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "_key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_key"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "text":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Text = data
		case "marks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("marks"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Marks = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Block(ctx context.Context, sel ast.SelectionSet, obj models.Block) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case models.ImageBlock:
		return ec._ImageBlock(ctx, sel, &obj)
	case *models.ImageBlock:
		if obj == nil {
			return graphql.Null
		}
		return ec._ImageBlock(ctx, sel, obj)
	case models.BreakBlock:
		return ec._BreakBlock(ctx, sel, &obj)
	case *models.BreakBlock:
		if obj == nil {
			return graphql.Null
		}
		return ec._BreakBlock(ctx, sel, obj)
	case models.BlockBlock:
		return ec._BlockBlock(ctx, sel, &obj)
	case *models.BlockBlock:
		if obj == nil {
			return graphql.Null
		}
		return ec._BlockBlock(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _MarkDef(ctx context.Context, sel ast.SelectionSet, obj models.MarkDef) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case models.LinkMarkDef:
		return ec._LinkMarkDef(ctx, sel, &obj)
	case *models.LinkMarkDef:
		if obj == nil {
			return graphql.Null
		}
		return ec._LinkMarkDef(ctx, sel, obj)
	case models.CommentMarkDef:
		return ec._CommentMarkDef(ctx, sel, &obj)
	case *models.CommentMarkDef:
		if obj == nil {
			return graphql.Null
		}
		return ec._CommentMarkDef(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var blockBlockImplementors = []string{"BlockBlock", "Block"}

func (ec *executionContext) _BlockBlock(ctx context.Context, sel ast.SelectionSet, obj *models.BlockBlock) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blockBlockImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BlockBlock")
		case "_type":
			out.Values[i] = ec._BlockBlock__type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "_key":
			out.Values[i] = ec._BlockBlock__key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "style":
			out.Values[i] = ec._BlockBlock_style(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "children":
			out.Values[i] = ec._BlockBlock_children(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "markDefs":
			out.Values[i] = ec._BlockBlock_markDefs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "listItem":
			out.Values[i] = ec._BlockBlock_listItem(ctx, field, obj)
		case "level":
			out.Values[i] = ec._BlockBlock_level(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var blocksImplementors = []string{"Blocks"}

func (ec *executionContext) _Blocks(ctx context.Context, sel ast.SelectionSet, obj *models.Blocks) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blocksImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Blocks")
		case "block":
			out.Values[i] = ec._Blocks_block(ctx, field, obj)
		case "image":
			out.Values[i] = ec._Blocks_image(ctx, field, obj)
		case "break":
			out.Values[i] = ec._Blocks_break(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var breakBlockImplementors = []string{"BreakBlock", "Block"}

func (ec *executionContext) _BreakBlock(ctx context.Context, sel ast.SelectionSet, obj *models.BreakBlock) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, breakBlockImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BreakBlock")
		case "_type":
			out.Values[i] = ec._BreakBlock__type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "_key":
			out.Values[i] = ec._BreakBlock__key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var commentMarkDefImplementors = []string{"CommentMarkDef", "MarkDef"}

func (ec *executionContext) _CommentMarkDef(ctx context.Context, sel ast.SelectionSet, obj *models.CommentMarkDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, commentMarkDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommentMarkDef")
		case "_key":
			out.Values[i] = ec._CommentMarkDef__key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "_type":
			out.Values[i] = ec._CommentMarkDef__type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "text":
			out.Values[i] = ec._CommentMarkDef_text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageBlockImplementors = []string{"ImageBlock", "Block"}

func (ec *executionContext) _ImageBlock(ctx context.Context, sel ast.SelectionSet, obj *models.ImageBlock) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageBlockImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageBlock")
		case "_type":
			out.Values[i] = ec._ImageBlock__type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "_key":
			out.Values[i] = ec._ImageBlock__key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "src":
			out.Values[i] = ec._ImageBlock_src(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "alt":
			out.Values[i] = ec._ImageBlock_alt(ctx, field, obj)
		case "caption":
			out.Values[i] = ec._ImageBlock_caption(ctx, field, obj)
		case "width":
			out.Values[i] = ec._ImageBlock_width(ctx, field, obj)
		case "height":
			out.Values[i] = ec._ImageBlock_height(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var linkMarkDefImplementors = []string{"LinkMarkDef", "MarkDef"}

func (ec *executionContext) _LinkMarkDef(ctx context.Context, sel ast.SelectionSet, obj *models.LinkMarkDef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, linkMarkDefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LinkMarkDef")
		case "_key":
			out.Values[i] = ec._LinkMarkDef__key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "_type":
			out.Values[i] = ec._LinkMarkDef__type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "href":
			out.Values[i] = ec._LinkMarkDef_href(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "title":
			out.Values[i] = ec._LinkMarkDef_title(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var markDefsImplementors = []string{"MarkDefs"}

func (ec *executionContext) _MarkDefs(ctx context.Context, sel ast.SelectionSet, obj *models.MarkDefs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, markDefsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MarkDefs")
		case "link":
			out.Values[i] = ec._MarkDefs_link(ctx, field, obj)
		case "comment":
			out.Values[i] = ec._MarkDefs_comment(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var portableTextImplementors = []string{"PortableText"}

func (ec *executionContext) _PortableText(ctx context.Context, sel ast.SelectionSet, obj *models.PortableText) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, portableTextImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PortableText")
		case "blocks":
			out.Values[i] = ec._PortableText_blocks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var spanImplementors = []string{"Span"}

func (ec *executionContext) _Span(ctx context.Context, sel ast.SelectionSet, obj *models.Span) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, spanImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Span")
		case "_type":
			out.Values[i] = ec._Span__type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "_key":
			out.Values[i] = ec._Span__key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "text":
			out.Values[i] = ec._Span_text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "marks":
			out.Values[i] = ec._Span_marks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBlockInput2ᚕᚖsharedᚋpkgᚋgraphᚋmodelsᚐBlockInputᚄ(ctx context.Context, v any) ([]*models.BlockInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*models.BlockInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBlockInput2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐBlockInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNBlockInput2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐBlockInput(ctx context.Context, v any) (*models.BlockInput, error) {
	res, err := ec.unmarshalInputBlockInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBlockType2sharedᚋpkgᚋgraphᚋmodelsᚐBlockType(ctx context.Context, v any) (models.BlockType, error) {
	var res models.BlockType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBlockType2sharedᚋpkgᚋgraphᚋmodelsᚐBlockType(ctx context.Context, sel ast.SelectionSet, v models.BlockType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNBlocks2ᚕᚖsharedᚋpkgᚋgraphᚋmodelsᚐBlocksᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Blocks) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBlocks2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐBlocks(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBlocks2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐBlocks(ctx context.Context, sel ast.SelectionSet, v *models.Blocks) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Blocks(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMarkDefInput2ᚕᚖsharedᚋpkgᚋgraphᚋmodelsᚐMarkDefInputᚄ(ctx context.Context, v any) ([]*models.MarkDefInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*models.MarkDefInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMarkDefInput2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐMarkDefInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMarkDefInput2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐMarkDefInput(ctx context.Context, v any) (*models.MarkDefInput, error) {
	res, err := ec.unmarshalInputMarkDefInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMarkDefType2sharedᚋpkgᚋgraphᚋmodelsᚐMarkDefType(ctx context.Context, v any) (models.MarkDefType, error) {
	var res models.MarkDefType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMarkDefType2sharedᚋpkgᚋgraphᚋmodelsᚐMarkDefType(ctx context.Context, sel ast.SelectionSet, v models.MarkDefType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMarkDefs2ᚕᚖsharedᚋpkgᚋgraphᚋmodelsᚐMarkDefsᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.MarkDefs) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMarkDefs2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐMarkDefs(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMarkDefs2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐMarkDefs(ctx context.Context, sel ast.SelectionSet, v *models.MarkDefs) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MarkDefs(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPortableTextInput2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐPortableTextInput(ctx context.Context, v any) (*models.PortableTextInput, error) {
	res, err := ec.unmarshalInputPortableTextInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSpan2ᚕᚖsharedᚋpkgᚋgraphᚋmodelsᚐSpanᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Span) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSpan2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐSpan(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSpan2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐSpan(ctx context.Context, sel ast.SelectionSet, v *models.Span) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Span(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSpanInput2ᚕᚖsharedᚋpkgᚋgraphᚋmodelsᚐSpanInputᚄ(ctx context.Context, v any) ([]*models.SpanInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*models.SpanInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSpanInput2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐSpanInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNSpanInput2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐSpanInput(ctx context.Context, v any) (*models.SpanInput, error) {
	res, err := ec.unmarshalInputSpanInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSpanType2sharedᚋpkgᚋgraphᚋmodelsᚐSpanType(ctx context.Context, v any) (models.SpanType, error) {
	var res models.SpanType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSpanType2sharedᚋpkgᚋgraphᚋmodelsᚐSpanType(ctx context.Context, sel ast.SelectionSet, v models.SpanType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNStyleType2sharedᚋpkgᚋgraphᚋmodelsᚐStyleType(ctx context.Context, v any) (models.StyleType, error) {
	var res models.StyleType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStyleType2sharedᚋpkgᚋgraphᚋmodelsᚐStyleType(ctx context.Context, sel ast.SelectionSet, v models.StyleType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalOBlockBlock2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐBlockBlock(ctx context.Context, sel ast.SelectionSet, v *models.BlockBlock) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BlockBlock(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBlockBlockInput2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐBlockBlockInput(ctx context.Context, v any) (*models.BlockBlockInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBlockBlockInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBreakBlock2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐBreakBlock(ctx context.Context, sel ast.SelectionSet, v *models.BreakBlock) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BreakBlock(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBreakBlockInput2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐBreakBlockInput(ctx context.Context, v any) (*models.BreakBlockInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBreakBlockInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCommentMarkDef2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐCommentMarkDef(ctx context.Context, sel ast.SelectionSet, v *models.CommentMarkDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CommentMarkDef(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCommentMarkDefInput2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐCommentMarkDefInput(ctx context.Context, v any) (*models.CommentMarkDefInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCommentMarkDefInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOImageBlock2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐImageBlock(ctx context.Context, sel ast.SelectionSet, v *models.ImageBlock) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ImageBlock(ctx, sel, v)
}

func (ec *executionContext) unmarshalOImageBlockInput2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐImageBlockInput(ctx context.Context, v any) (*models.ImageBlockInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputImageBlockInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLinkMarkDef2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐLinkMarkDef(ctx context.Context, sel ast.SelectionSet, v *models.LinkMarkDef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LinkMarkDef(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLinkMarkDefInput2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐLinkMarkDefInput(ctx context.Context, v any) (*models.LinkMarkDefInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLinkMarkDefInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOListItemType2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐListItemType(ctx context.Context, v any) (*models.ListItemType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(models.ListItemType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOListItemType2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐListItemType(ctx context.Context, sel ast.SelectionSet, v *models.ListItemType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOPortableText2ᚖsharedᚋpkgᚋgraphᚋmodelsᚐPortableText(ctx context.Context, sel ast.SelectionSet, v *models.PortableText) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PortableText(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
