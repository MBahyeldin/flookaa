package models

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"shared/external/db/mongo"
	"shared/external/db/nats"
	"shared/pkg/db"
	"shared/pkg/graph"
	"shared/pkg/graph/models"
	"shared/pkg/subject"
	portabletext "shared/util/portableText"
	"sync"
	"time"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input models.PostInput) (*models.PostGenericDocument, error) {
	// Create Object in Mongodb
	Collection := mongo.Client.Database("app").Collection("objects")
	userId, err := getUserIdFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}
	rawContent, err := json.Marshal(input.Content)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal content: %w", err)
	}

	id := fmt.Sprintf("obj_%d_%d", userId, time.Now().Unix())

	object := &models.PostGenericDocument{
		ID:       id,
		Type:     models.PostTypePost,
		ParentID: nil,
		AuthorID: userId,
		Tags:     input.Tags,
		Owner: &models.Owner{
			ID:   input.Owner.ID,
			Type: input.Owner.Type,
		},
		Content:        portabletext.ParseContent(*input.Content),
		RawContent:     string(rawContent),
		CreatedAt:      time.Now(),
		UpdatedAt:      time.Now(),
		Privacy:        models.Privacy(input.Privacy.String()),
		AllowedUserIds: input.AllowedUserIds,
		DeniedUserIds:  input.DeniedUserIds,
	}

	_, insertError := Collection.InsertOne(ctx, object)
	if insertError != nil {
		return nil, fmt.Errorf("failed to insert object: %w", insertError)
	}
	metaData := map[string]any{
		"object_id":  object.ID,
		"owner_id":   input.Owner.ID,
		"owner_type": input.Owner.Type,
		"author_id":  userId,
		"tags":       input.Tags,
		"created_at": object.CreatedAt,
	}

	var ownerType db.OwnerEnum
	switch input.Owner.Type {
	case models.OwnerTypeUser:
		ownerType = db.OwnerEnumUSER
	case models.OwnerTypeChannel:
		ownerType = db.OwnerEnumCHANNEL
	default:
		ownerType = db.OwnerEnumUSER
	}

	event := db.CreateEventParams{
		Name:       db.EventEnumPost,
		Action:     db.EventActionEnumCreate,
		TargetID:   fmt.Sprintf("%d", input.Owner.ID),
		TargetType: db.EventTargetTypeEnumCHANNEL,
		Owner:      ownerType,
		OwnerID:    int64(input.Owner.ID),
		ActorID:    int64(userId),
	}

	_, err = db.New(r.Postgres).CreateEvent(ctx, event)

	if err != nil {
		log.Println("Warning: failed to create event:", err)
	}

	if err != nil {
		log.Println("Warning: failed to marshal metadata for NATS:", err)
	}
	var streamName = nats.CONTENT_EVENTS_STREAM
	subjectHelper := subject.New(&streamName, &models.Owner{
		ID:   input.Owner.ID,
		Type: input.Owner.Type,
	}, string(db.EventEnumPost), string(db.EventActionEnumCreate))

	err = nats.NatsHelperInstance.PublishMessage(
		subjectHelper.GetSubject(),
		&nats.MessageType{Event: *models.EventMapper(event), Payload: metaData},
	)

	if err != nil {
		log.Println("Warning: failed to publish post creation event to NATS:", err)
	}

	return object, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input models.CommentInput) (*models.PostGenericDocument, error) {
	Collection := mongo.Client.Database("app").Collection("objects")
	userId, err := getUserIdFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}
	rawContent, err := json.Marshal(input.Content)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal content: %w", err)
	}

	object := &models.PostGenericDocument{
		ID:         fmt.Sprintf("obj_%d_%d", userId, time.Now().Unix()),
		Type:       models.PostTypeComment,
		ParentID:   &input.ParentID,
		AuthorID:   userId,
		Tags:       input.Tags,
		RawContent: string(rawContent),
		CreatedAt:  time.Now(),
		UpdatedAt:  time.Now(),
		Owner: &models.Owner{
			ID:   input.Owner.ID,
			Type: input.Owner.Type,
		},
		Privacy:        models.Privacy(input.Privacy.String()),
		AllowedUserIds: input.AllowedUserIds,
		DeniedUserIds:  input.DeniedUserIds,
	}

	_, insertError := Collection.InsertOne(ctx, object)
	if insertError != nil {
		return nil, fmt.Errorf("failed to insert object: %w", insertError)
	}

	author, err := resolveUserCached(ctx, userId, r.Postgres)
	if err != nil {
		return nil, fmt.Errorf("failed to resolve author: %w", err)
	}

	comment := models.Comment{
		ID:         object.ID,
		Type:       object.Type,
		ParentID:   *object.ParentID,
		AuthorID:   object.AuthorID,
		Author:     author,
		Tags:       object.Tags,
		RawContent: object.RawContent,
		CreatedAt:  object.CreatedAt,
		UpdatedAt:  object.UpdatedAt,
		Privacy:    object.Privacy,
		Edited:     object.Edited,
		Meta: &models.Meta{
			LikesCount:  0,
			SharesCount: 0,
			ViewsCount:  0,
		},
		PersonalizedMeta: &models.PersonalizedMeta{
			LikedByUser:  false,
			SharedByUser: false,
			ViewedByUser: false,
			ACL: &models.ACL{
				CanView:    true,
				CanComment: true,
				CanReply:   true,
				CanLike:    true,
				CanShare:   true,
			},
		},
	}

	var targetType db.EventTargetTypeEnum

	if input.Level == 1 {
		targetType = db.EventTargetTypeEnumPOST
	} else {
		targetType = db.EventTargetTypeEnumCOMMENT
	}

	event := db.CreateEventParams{
		Name:       db.EventEnumComment,
		Action:     db.EventActionEnumCreate,
		TargetID:   input.ParentID,
		TargetType: targetType,
		Owner:      db.OwnerEnum(input.Owner.Type.String()),
		OwnerID:    int64(input.Owner.ID),
		ActorID:    int64(userId),
	}

	_, err = db.New(r.Postgres).CreateEvent(ctx, event)

	if err != nil {
		log.Println("Warning: failed to create event:", err)
	}

	if err != nil {
		log.Println("Warning: failed to marshal metadata for NATS:", err)
	}
	var streamName = nats.CONTENT_EVENTS_STREAM
	subjectHelper := subject.New(&streamName, &models.Owner{
		ID:   input.Owner.ID,
		Type: input.Owner.Type,
	}, string(db.EventEnumComment), string(db.EventActionEnumCreate))

	err = nats.NatsHelperInstance.PublishMessage(
		subjectHelper.GetSubject(),
		&nats.MessageType{Event: *models.EventMapper(event), Payload: comment},
	)

	if err != nil {
		log.Println("Warning: failed to publish post creation event to NATS:", err)
	}

	return object, nil
}

// CreateLike is the resolver for the createLike field.
func (r *mutationResolver) CreateLike(ctx context.Context, input models.LikeInput) (bool, error) {
	userId, err := getUserIdFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthenticated: %w", err)
	}

	q := db.New(r.Postgres)
	isLikedByUser, err := q.IsUserLikedTarget(ctx, db.IsUserLikedTargetParams{
		TargetID: input.TargetID,
		ActorID:  int64(userId),
	})

	if err != nil {
		return false, fmt.Errorf("failed to check if user liked target: %w", err)
	}

	// No change in like status
	if isLikedByUser && input.Liked {
		return true, nil
	}

	// User wants to unlike but hasn't liked before
	if !isLikedByUser && !input.Liked {
		return false, nil
	}

	var action db.EventActionEnum

	if isLikedByUser && !input.Liked {
		action = db.EventActionEnumDelete
	} else if !isLikedByUser && input.Liked {
		action = db.EventActionEnumCreate
	}

	event := db.CreateEventParams{
		Name:       db.EventEnumLike,
		Action:     action,
		TargetID:   input.TargetID,
		TargetType: db.EventTargetTypeEnum(input.TargetType.String()),
		Owner:      db.OwnerEnum(input.Owner.Type),
		OwnerID:    input.Owner.ID,
		ActorID:    int64(userId),
	}

	switch action {
	case db.EventActionEnumDelete:
		err = q.UnlikeEvent(ctx, db.UnlikeEventParams{
			TargetID: input.TargetID,
			ActorID:  int64(userId),
		})
		if err != nil {
			return false, fmt.Errorf("failed to unlike event: %w", err)
		}
	case db.EventActionEnumCreate:
		_, err = q.CreateEvent(ctx, event)
		if err != nil {
			return false, fmt.Errorf("failed to create like event: %w", err)
		}
	}

	var streamName = nats.CONTENT_EVENTS_STREAM

	subjectHelper := subject.New(&streamName, &models.Owner{
		ID:   input.Owner.ID,
		Type: input.Owner.Type,
	}, string(db.EventEnumLike), string(db.EventActionEnumCreate))

	nats.NatsHelperInstance.PublishMessage(
		subjectHelper.GetSubject(),
		&nats.MessageType{Event: *models.EventMapper(event), Payload: nil},
	)

	return true, nil
}

// DeletePost is the resolver for the deletePost field.
func (r *mutationResolver) DeletePost(ctx context.Context, id string, owner models.OwnerInput) (bool, error) {
	panic(fmt.Errorf("not implemented: DeletePost - deletePost"))
}

// DeleteComment is the resolver for the deleteComment field.
func (r *mutationResolver) DeleteComment(ctx context.Context, id string, owner models.OwnerInput) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteComment - deleteComment"))
}

// DeleteReply is the resolver for the deleteReply field.
func (r *mutationResolver) DeleteReply(ctx context.Context, id string, owner models.OwnerInput) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteReply - deleteReply"))
}

// GetPosts is the resolver for the getPosts field.
func (r *queryResolver) GetPosts(ctx context.Context, owner models.OwnerInput, ids []string, limit *int32, offset *int32) ([]*models.Post, error) {
	_, err := getUserIdFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}
	posts, err := getPosts(ctx, models.Owner{
		ID:   owner.ID,
		Type: owner.Type,
	}, &ids, r, *limit, *offset)
	if err != nil {
		return nil, fmt.Errorf("failed to get posts: %w", err)
	}
	return posts, nil
}

// GetComments is the resolver for the getComments field.
func (r *queryResolver) GetComments(ctx context.Context, parentID string, limit *int32, offset *int32) ([]*models.Comment, error) {
	_, err := getUserIdFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}
	comments, err := getComments(ctx, parentID, r, *limit, *offset)
	if err != nil {
		return nil, fmt.Errorf("failed to get comments: %w", err)
	}
	return comments, nil
}

// GetChannel is the resolver for the getChannel field.
func (r *queryResolver) GetChannel(ctx context.Context, id int64) (*models.Channel, error) {
	userId, err := getUserIdFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthenticated: %w", err)
	}

	var channel db.GetChannelRow
	var channelErr, postsErr error
	var posts []*models.Post
	var ownerUser models.User
	wg := sync.WaitGroup{}
	wg.Add(3)

	// --- Fetch Channel Details + Owner ---
	go func() {
		defer wg.Done()
		q := db.New(r.Postgres)
		ctxTimeout, cancel := context.WithTimeout(ctx, 5*time.Second)
		defer cancel()

		channelResult, err := q.GetChannel(ctxTimeout, db.GetChannelParams{
			ID:      id,
			OwnerID: userId,
		})
		if err != nil {
			channelErr = err
			return
		}
		channel = channelResult

		// Owner lookup + cache
		cachedUser, err := resolveUserCached(ctx, channel.OwnerID, r.Postgres)
		if err != nil {
			channelErr = err
			return
		}
		ownerUser = *cachedUser
	}()

	// --- Fetch Posts + Comments using $lookup ---
	go func() {
		defer wg.Done()
		posts, postsErr = getPosts(ctx, models.Owner{
			ID:   id,
			Type: models.OwnerTypeChannel,
		}, nil, r, 10, 0)
	}()

	var totalPostsCount int32
	// --- Fetch Total Posts Count ---
	go func() {
		ctxTimeout, cancel := context.WithTimeout(ctx, 5*time.Second)
		defer cancel()
		defer wg.Done()

		count, err := getTotalPostsCountForChannel(ctxTimeout, id, r)
		if err != nil {
			log.Println("Warning: failed to get total posts count for channel:", err)
			return
		}
		totalPostsCount = int32(count)
	}()

	fmt.Printf("Fetching channel %d details and posts concurrently...\n", id)
	fmt.Println("Found posts:", len(posts))

	wg.Wait()

	if channelErr != nil {
		return nil, channelErr
	}
	if postsErr != nil {
		return nil, postsErr
	}

	return &models.Channel{
		ID:             channel.ID,
		Name:           channel.Name,
		Description:    &channel.Description,
		BannerImageURL: &channel.Banner,
		ThumbnailURL:   &channel.Thumbnail,
		CreatedAt:      channel.CreatedAt.Time,
		UpdatedAt:      channel.UpdatedAt.Time,
		Posts:          posts,
		TotalPosts:     totalPostsCount,
		Owner:          &ownerUser,
		IsMember:       channel.IsMember,
		IsFollower:     channel.IsFollower,
	}, nil
}

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
