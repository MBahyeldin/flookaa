// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"
)

type Block interface {
	IsBlock()
	GetType() BlockType
	GetKey() string
}

// Mark definitions (annotations) base
type MarkDef interface {
	IsMarkDef()
	GetKey() string
	GetType() MarkDefType
}

type ACL struct {
	CanView    bool `json:"canView"`
	CanComment bool `json:"canComment"`
	CanReply   bool `json:"canReply"`
	CanShare   bool `json:"canShare"`
	CanLike    bool `json:"canLike"`
}

type BlockBlock struct {
	Type     BlockType     `json:"_type"`
	Key      string        `json:"_key"`
	Style    StyleType     `json:"style"`
	Children []*Span       `json:"children"`
	MarkDefs []*MarkDefs   `json:"markDefs"`
	ListItem *ListItemType `json:"listItem,omitempty"`
	Level    *int32        `json:"level,omitempty"`
}

func (BlockBlock) IsBlock()                {}
func (this BlockBlock) GetType() BlockType { return this.Type }
func (this BlockBlock) GetKey() string     { return this.Key }

// Block inputs
type BlockBlockInput struct {
	Type     BlockType       `json:"_type"`
	Key      string          `json:"_key"`
	Style    StyleType       `json:"style"`
	Children []*SpanInput    `json:"children"`
	MarkDefs []*MarkDefInput `json:"markDefs"`
	ListItem *ListItemType   `json:"listItem,omitempty"`
	Level    *int32          `json:"level,omitempty"`
}

// Oneof input for blocks
type BlockInput struct {
	Block *BlockBlockInput `json:"block,omitempty"`
	Image *ImageBlockInput `json:"image,omitempty"`
	Break *BreakBlockInput `json:"break,omitempty"`
}

// Union of all possible blocks
type Blocks struct {
	Block *BlockBlock `json:"block,omitempty"`
	Image *ImageBlock `json:"image,omitempty"`
	Break *BreakBlock `json:"break,omitempty"`
}

type BreakBlock struct {
	Type BlockType `json:"_type"`
	Key  string    `json:"_key"`
}

func (BreakBlock) IsBlock()                {}
func (this BreakBlock) GetType() BlockType { return this.Type }
func (this BreakBlock) GetKey() string     { return this.Key }

type BreakBlockInput struct {
	Type BlockType `json:"_type"`
	Key  string    `json:"_key"`
}

type Channel struct {
	ID              int64     `json:"id"`
	Name            string    `json:"name"`
	Description     *string   `json:"description,omitempty"`
	BannerImageURL  *string   `json:"bannerImageUrl,omitempty"`
	ThumbnailURL    *string   `json:"thumbnailUrl,omitempty"`
	ProfileImageURL *string   `json:"profileImageUrl,omitempty"`
	CreatedAt       time.Time `json:"createdAt"`
	UpdatedAt       time.Time `json:"updatedAt"`
	Posts           []*Post   `json:"posts"`
	TotalPosts      int32     `json:"totalPosts"`
	Owner           *Persona  `json:"owner"`
	MembersCount    *int32    `json:"membersCount,omitempty"`
	FollowersCount  *int32    `json:"followersCount,omitempty"`
	IsMember        bool      `json:"isMember"`
	IsFollower      bool      `json:"isFollower"`
}

type Comment struct {
	ID                string            `json:"_id"`
	Type              PostType          `json:"type"`
	ParentID          string            `json:"parentId"`
	AuthorID          int64             `json:"authorId"`
	Author            *Persona          `json:"author"`
	Content           *PortableText     `json:"content,omitempty"`
	RawContent        string            `json:"rawContent"`
	Tags              []string          `json:"tags"`
	CreatedAt         time.Time         `json:"createdAt"`
	UpdatedAt         time.Time         `json:"updatedAt"`
	DeletedAt         *time.Time        `json:"deletedAt,omitempty"`
	Edited            bool              `json:"edited"`
	DeniedPersonaIds  []int64           `json:"deniedPersonaIds"`
	AllowedPersonaIds []int64           `json:"allowedPersonaIds"`
	Privacy           Privacy           `json:"privacy"`
	Meta              *Meta             `json:"meta"`
	PersonalizedMeta  *PersonalizedMeta `json:"personalizedMeta"`
}

type CommentInput struct {
	ParentID          string       `json:"parentId"`
	Level             int32        `json:"level"`
	AuthorID          int64        `json:"authorId"`
	Content           *SimpleInput `json:"content"`
	Tags              []string     `json:"tags,omitempty"`
	Owner             *OwnerInput  `json:"owner"`
	Privacy           Privacy      `json:"privacy"`
	DeniedPersonaIds  []int64      `json:"deniedPersonaIds"`
	AllowedPersonaIds []int64      `json:"allowedPersonaIds"`
}

// MarkDef for comments
type CommentMarkDef struct {
	Key  string      `json:"_key"`
	Type MarkDefType `json:"_type"`
	Text string      `json:"text"`
}

func (CommentMarkDef) IsMarkDef()                {}
func (this CommentMarkDef) GetKey() string       { return this.Key }
func (this CommentMarkDef) GetType() MarkDefType { return this.Type }

type CommentMarkDefInput struct {
	Key  string      `json:"_key"`
	Type MarkDefType `json:"_type"`
	Text string      `json:"text"`
}

type ImageBlock struct {
	Type    BlockType `json:"_type"`
	Key     string    `json:"_key"`
	Src     string    `json:"src"`
	Alt     *string   `json:"alt,omitempty"`
	Caption *string   `json:"caption,omitempty"`
	Width   *string   `json:"width,omitempty"`
	Height  *string   `json:"height,omitempty"`
}

func (ImageBlock) IsBlock()                {}
func (this ImageBlock) GetType() BlockType { return this.Type }
func (this ImageBlock) GetKey() string     { return this.Key }

type ImageBlockInput struct {
	Type    BlockType `json:"_type"`
	Key     string    `json:"_key"`
	Src     string    `json:"src"`
	Alt     *string   `json:"alt,omitempty"`
	Caption *string   `json:"caption,omitempty"`
	Width   *string   `json:"width,omitempty"`
	Height  *string   `json:"height,omitempty"`
}

type LikeInput struct {
	TargetID   string      `json:"targetId"`
	TargetType PostType    `json:"targetType"`
	Owner      *OwnerInput `json:"owner"`
	Liked      bool        `json:"liked"`
}

// MarkDef for links
type LinkMarkDef struct {
	Key   string      `json:"_key"`
	Type  MarkDefType `json:"_type"`
	Href  string      `json:"href"`
	Title *string     `json:"title,omitempty"`
}

func (LinkMarkDef) IsMarkDef()                {}
func (this LinkMarkDef) GetKey() string       { return this.Key }
func (this LinkMarkDef) GetType() MarkDefType { return this.Type }

type LinkMarkDefInput struct {
	Key   string      `json:"_key"`
	Type  MarkDefType `json:"_type"`
	Href  string      `json:"href"`
	Title *string     `json:"title,omitempty"`
}

// Oneof input for markDefs
type MarkDefInput struct {
	Link    *LinkMarkDefInput    `json:"link,omitempty"`
	Comment *CommentMarkDefInput `json:"comment,omitempty"`
}

// Union of all possible markDefs
type MarkDefs struct {
	Link    *LinkMarkDef    `json:"link,omitempty"`
	Comment *CommentMarkDef `json:"comment,omitempty"`
}

type Media struct {
	Type MediaType `json:"type"`
	URL  string    `json:"url"`
}

type MediaInput struct {
	Type MediaType `json:"type"`
	URL  string    `json:"url"`
}

type Meta struct {
	LikesCount    int32  `json:"likesCount"`
	SharesCount   int32  `json:"sharesCount"`
	ViewsCount    int32  `json:"viewsCount"`
	CommentsCount *int32 `json:"commentsCount,omitempty"`
}

type Mutation struct {
}

type Owner struct {
	Type OwnerType `json:"type"`
	ID   int64     `json:"id"`
}

type OwnerInput struct {
	ID   int64     `json:"id"`
	Type OwnerType `json:"type"`
}

type Persona struct {
	ID              int64   `json:"id"`
	Username        string  `json:"username"`
	FullName        string  `json:"fullName"`
	ProfileImageURL *string `json:"profileImageUrl,omitempty"`
}

type PersonalizedMeta struct {
	LikedByPersona  bool `json:"likedByPersona"`
	SharedByPersona bool `json:"sharedByPersona"`
	ViewedByPersona bool `json:"viewedByPersona"`
	ACL             *ACL `json:"acl"`
}

// Top-level PortableText document
type PortableText struct {
	Blocks []*Blocks `json:"blocks"`
}

type PortableTextInput struct {
	Blocks []*BlockInput `json:"blocks"`
}

type Post struct {
	ID                string            `json:"_id"`
	Type              PostType          `json:"type"`
	AuthorID          int64             `json:"authorId"`
	Author            *Persona          `json:"author"`
	Owner             *Owner            `json:"owner"`
	Content           *PortableText     `json:"content,omitempty"`
	RawContent        string            `json:"rawContent"`
	Tags              []string          `json:"tags"`
	CreatedAt         time.Time         `json:"createdAt"`
	UpdatedAt         time.Time         `json:"updatedAt"`
	DeletedAt         *time.Time        `json:"deletedAt,omitempty"`
	Edited            bool              `json:"edited"`
	Privacy           Privacy           `json:"privacy"`
	DeniedPersonaIds  []int64           `json:"deniedPersonaIds"`
	AllowedPersonaIds []int64           `json:"allowedPersonaIds"`
	Meta              *Meta             `json:"meta"`
	PersonalizedMeta  *PersonalizedMeta `json:"personalizedMeta"`
}

type PostGenericDocument struct {
	ID                string        `json:"_id"`
	Type              PostType      `json:"type"`
	ParentID          *string       `json:"parentId,omitempty"`
	AuthorID          int64         `json:"authorId"`
	Owner             *Owner        `json:"owner,omitempty"`
	Content           *PortableText `json:"content,omitempty"`
	RawContent        string        `json:"rawContent"`
	Tags              []string      `json:"tags"`
	CreatedAt         time.Time     `json:"createdAt"`
	UpdatedAt         time.Time     `json:"updatedAt"`
	DeletedAt         *time.Time    `json:"deletedAt,omitempty"`
	Edited            bool          `json:"edited"`
	Privacy           Privacy       `json:"privacy"`
	DeniedPersonaIds  []int64       `json:"deniedPersonaIds,omitempty"`
	AllowedPersonaIds []int64       `json:"allowedPersonaIds,omitempty"`
}

type PostInput struct {
	AuthorID          int64              `json:"authorId"`
	Content           *PortableTextInput `json:"content"`
	Tags              []string           `json:"tags,omitempty"`
	Owner             *OwnerInput        `json:"owner"`
	Privacy           Privacy            `json:"privacy"`
	DeniedPersonaIds  []int64            `json:"deniedPersonaIds"`
	AllowedPersonaIds []int64            `json:"allowedPersonaIds"`
}

type Query struct {
}

type SimpleInput struct {
	Type    SimpleInputType `json:"type"`
	Content string          `json:"content"`
}

type Span struct {
	Type  SpanType `json:"_type"`
	Key   string   `json:"_key"`
	Text  string   `json:"text"`
	Marks []string `json:"marks"`
}

type SpanInput struct {
	Type  SpanType `json:"_type"`
	Key   string   `json:"_key"`
	Text  string   `json:"text"`
	Marks []string `json:"marks"`
}

// A block of rich text
type BlockType string

const (
	BlockTypeBlock BlockType = "block"
	BlockTypeImage BlockType = "image"
	BlockTypeBreak BlockType = "break"
)

var AllBlockType = []BlockType{
	BlockTypeBlock,
	BlockTypeImage,
	BlockTypeBreak,
}

func (e BlockType) IsValid() bool {
	switch e {
	case BlockTypeBlock, BlockTypeImage, BlockTypeBreak:
		return true
	}
	return false
}

func (e BlockType) String() string {
	return string(e)
}

func (e *BlockType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BlockType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BlockType", str)
	}
	return nil
}

func (e BlockType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *BlockType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e BlockType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ListItemType string

const (
	ListItemTypeBullet ListItemType = "bullet"
	ListItemTypeNumber ListItemType = "number"
)

var AllListItemType = []ListItemType{
	ListItemTypeBullet,
	ListItemTypeNumber,
}

func (e ListItemType) IsValid() bool {
	switch e {
	case ListItemTypeBullet, ListItemTypeNumber:
		return true
	}
	return false
}

func (e ListItemType) String() string {
	return string(e)
}

func (e *ListItemType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ListItemType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ListItemType", str)
	}
	return nil
}

func (e ListItemType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ListItemType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ListItemType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MarkDefType string

const (
	MarkDefTypeLink    MarkDefType = "link"
	MarkDefTypeComment MarkDefType = "comment"
)

var AllMarkDefType = []MarkDefType{
	MarkDefTypeLink,
	MarkDefTypeComment,
}

func (e MarkDefType) IsValid() bool {
	switch e {
	case MarkDefTypeLink, MarkDefTypeComment:
		return true
	}
	return false
}

func (e MarkDefType) String() string {
	return string(e)
}

func (e *MarkDefType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarkDefType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarkDefType", str)
	}
	return nil
}

func (e MarkDefType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MarkDefType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MarkDefType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MediaType string

const (
	MediaTypeImage MediaType = "IMAGE"
	MediaTypeVideo MediaType = "VIDEO"
	MediaTypeGif   MediaType = "GIF"
)

var AllMediaType = []MediaType{
	MediaTypeImage,
	MediaTypeVideo,
	MediaTypeGif,
}

func (e MediaType) IsValid() bool {
	switch e {
	case MediaTypeImage, MediaTypeVideo, MediaTypeGif:
		return true
	}
	return false
}

func (e MediaType) String() string {
	return string(e)
}

func (e *MediaType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MediaType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MediaType", str)
	}
	return nil
}

func (e MediaType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MediaType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MediaType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type OwnerType string

const (
	OwnerTypePersona OwnerType = "PERSONA"
	OwnerTypeChannel OwnerType = "CHANNEL"
	OwnerTypePage    OwnerType = "PAGE"
)

var AllOwnerType = []OwnerType{
	OwnerTypePersona,
	OwnerTypeChannel,
	OwnerTypePage,
}

func (e OwnerType) IsValid() bool {
	switch e {
	case OwnerTypePersona, OwnerTypeChannel, OwnerTypePage:
		return true
	}
	return false
}

func (e OwnerType) String() string {
	return string(e)
}

func (e *OwnerType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OwnerType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OwnerType", str)
	}
	return nil
}

func (e OwnerType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OwnerType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OwnerType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type PostType string

const (
	PostTypePost    PostType = "POST"
	PostTypeComment PostType = "COMMENT"
	PostTypeReply   PostType = "REPLY"
)

var AllPostType = []PostType{
	PostTypePost,
	PostTypeComment,
	PostTypeReply,
}

func (e PostType) IsValid() bool {
	switch e {
	case PostTypePost, PostTypeComment, PostTypeReply:
		return true
	}
	return false
}

func (e PostType) String() string {
	return string(e)
}

func (e *PostType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PostType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PostType", str)
	}
	return nil
}

func (e PostType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PostType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PostType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type Privacy string

const (
	PrivacyPublic  Privacy = "PUBLIC"
	PrivacyFriends Privacy = "FRIENDS"
	PrivacyPrivate Privacy = "PRIVATE"
)

var AllPrivacy = []Privacy{
	PrivacyPublic,
	PrivacyFriends,
	PrivacyPrivate,
}

func (e Privacy) IsValid() bool {
	switch e {
	case PrivacyPublic, PrivacyFriends, PrivacyPrivate:
		return true
	}
	return false
}

func (e Privacy) String() string {
	return string(e)
}

func (e *Privacy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Privacy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Privacy", str)
	}
	return nil
}

func (e Privacy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Privacy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Privacy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SimpleInputType string

const (
	SimpleInputTypeText  SimpleInputType = "TEXT"
	SimpleInputTypeMedia SimpleInputType = "MEDIA"
	SimpleInputTypeVoice SimpleInputType = "VOICE"
)

var AllSimpleInputType = []SimpleInputType{
	SimpleInputTypeText,
	SimpleInputTypeMedia,
	SimpleInputTypeVoice,
}

func (e SimpleInputType) IsValid() bool {
	switch e {
	case SimpleInputTypeText, SimpleInputTypeMedia, SimpleInputTypeVoice:
		return true
	}
	return false
}

func (e SimpleInputType) String() string {
	return string(e)
}

func (e *SimpleInputType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SimpleInputType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SimpleInputType", str)
	}
	return nil
}

func (e SimpleInputType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SimpleInputType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SimpleInputType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

// A span of text inside a block
type SpanType string

const (
	SpanTypeSpan SpanType = "span"
)

var AllSpanType = []SpanType{
	SpanTypeSpan,
}

func (e SpanType) IsValid() bool {
	switch e {
	case SpanTypeSpan:
		return true
	}
	return false
}

func (e SpanType) String() string {
	return string(e)
}

func (e *SpanType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SpanType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SpanType", str)
	}
	return nil
}

func (e SpanType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SpanType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SpanType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type StyleType string

const (
	StyleTypeNormal     StyleType = "normal"
	StyleTypeH1         StyleType = "h1"
	StyleTypeH2         StyleType = "h2"
	StyleTypeH3         StyleType = "h3"
	StyleTypeH4         StyleType = "h4"
	StyleTypeH5         StyleType = "h5"
	StyleTypeH6         StyleType = "h6"
	StyleTypeBlockquote StyleType = "blockquote"
)

var AllStyleType = []StyleType{
	StyleTypeNormal,
	StyleTypeH1,
	StyleTypeH2,
	StyleTypeH3,
	StyleTypeH4,
	StyleTypeH5,
	StyleTypeH6,
	StyleTypeBlockquote,
}

func (e StyleType) IsValid() bool {
	switch e {
	case StyleTypeNormal, StyleTypeH1, StyleTypeH2, StyleTypeH3, StyleTypeH4, StyleTypeH5, StyleTypeH6, StyleTypeBlockquote:
		return true
	}
	return false
}

func (e StyleType) String() string {
	return string(e)
}

func (e *StyleType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StyleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StyleType", str)
	}
	return nil
}

func (e StyleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *StyleType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e StyleType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
