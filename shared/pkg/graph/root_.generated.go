// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"errors"
	"shared/pkg/graph/models"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
	Oneof func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
}

type ComplexityRoot struct {
	ACL struct {
		CanComment func(childComplexity int) int
		CanLike    func(childComplexity int) int
		CanReply   func(childComplexity int) int
		CanShare   func(childComplexity int) int
		CanView    func(childComplexity int) int
	}

	BlockBlock struct {
		Children func(childComplexity int) int
		Key      func(childComplexity int) int
		Level    func(childComplexity int) int
		ListItem func(childComplexity int) int
		MarkDefs func(childComplexity int) int
		Style    func(childComplexity int) int
		Type     func(childComplexity int) int
	}

	Blocks struct {
		Block func(childComplexity int) int
		Break func(childComplexity int) int
		Image func(childComplexity int) int
	}

	BreakBlock struct {
		Key  func(childComplexity int) int
		Type func(childComplexity int) int
	}

	Channel struct {
		BannerImageURL  func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Description     func(childComplexity int) int
		FollowersCount  func(childComplexity int) int
		ID              func(childComplexity int) int
		IsFollower      func(childComplexity int) int
		IsMember        func(childComplexity int) int
		MembersCount    func(childComplexity int) int
		Name            func(childComplexity int) int
		Owner           func(childComplexity int) int
		Posts           func(childComplexity int) int
		ProfileImageURL func(childComplexity int) int
		ThumbnailURL    func(childComplexity int) int
		TotalPosts      func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
	}

	Comment struct {
		AllowedUserIds   func(childComplexity int) int
		Author           func(childComplexity int) int
		AuthorID         func(childComplexity int) int
		Content          func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		DeletedAt        func(childComplexity int) int
		DeniedUserIds    func(childComplexity int) int
		Edited           func(childComplexity int) int
		ID               func(childComplexity int) int
		Meta             func(childComplexity int) int
		ParentID         func(childComplexity int) int
		PersonalizedMeta func(childComplexity int) int
		Privacy          func(childComplexity int) int
		RawContent       func(childComplexity int) int
		Tags             func(childComplexity int) int
		Type             func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
	}

	CommentMarkDef struct {
		Key  func(childComplexity int) int
		Text func(childComplexity int) int
		Type func(childComplexity int) int
	}

	ImageBlock struct {
		Alt     func(childComplexity int) int
		Caption func(childComplexity int) int
		Height  func(childComplexity int) int
		Key     func(childComplexity int) int
		Src     func(childComplexity int) int
		Type    func(childComplexity int) int
		Width   func(childComplexity int) int
	}

	LinkMarkDef struct {
		Href  func(childComplexity int) int
		Key   func(childComplexity int) int
		Title func(childComplexity int) int
		Type  func(childComplexity int) int
	}

	MarkDefs struct {
		Comment func(childComplexity int) int
		Link    func(childComplexity int) int
	}

	Media struct {
		Type func(childComplexity int) int
		URL  func(childComplexity int) int
	}

	Meta struct {
		CommentsCount func(childComplexity int) int
		LikesCount    func(childComplexity int) int
		SharesCount   func(childComplexity int) int
		ViewsCount    func(childComplexity int) int
	}

	Mutation struct {
		CreateComment func(childComplexity int, input models.CommentInput) int
		CreateLike    func(childComplexity int, input models.LikeInput) int
		CreatePost    func(childComplexity int, input models.PostInput) int
		DeleteComment func(childComplexity int, id string, owner models.OwnerInput) int
		DeletePost    func(childComplexity int, id string, owner models.OwnerInput) int
		DeleteReply   func(childComplexity int, id string, owner models.OwnerInput) int
	}

	Owner struct {
		ID   func(childComplexity int) int
		Type func(childComplexity int) int
	}

	PersonalizedMeta struct {
		ACL          func(childComplexity int) int
		LikedByUser  func(childComplexity int) int
		SharedByUser func(childComplexity int) int
		ViewedByUser func(childComplexity int) int
	}

	PortableText struct {
		Blocks func(childComplexity int) int
	}

	Post struct {
		AllowedUserIds   func(childComplexity int) int
		Author           func(childComplexity int) int
		AuthorID         func(childComplexity int) int
		Content          func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		DeletedAt        func(childComplexity int) int
		DeniedUserIds    func(childComplexity int) int
		Edited           func(childComplexity int) int
		ID               func(childComplexity int) int
		Meta             func(childComplexity int) int
		Owner            func(childComplexity int) int
		PersonalizedMeta func(childComplexity int) int
		Privacy          func(childComplexity int) int
		RawContent       func(childComplexity int) int
		Tags             func(childComplexity int) int
		Type             func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
	}

	PostGenericDocument struct {
		AllowedUserIds func(childComplexity int) int
		AuthorID       func(childComplexity int) int
		Content        func(childComplexity int) int
		CreatedAt      func(childComplexity int) int
		DeletedAt      func(childComplexity int) int
		DeniedUserIds  func(childComplexity int) int
		Edited         func(childComplexity int) int
		ID             func(childComplexity int) int
		Owner          func(childComplexity int) int
		ParentID       func(childComplexity int) int
		Privacy        func(childComplexity int) int
		RawContent     func(childComplexity int) int
		Tags           func(childComplexity int) int
		Type           func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
	}

	Query struct {
		GetChannel  func(childComplexity int, id int64) int
		GetComments func(childComplexity int, parentID string, limit *int32, offset *int32) int
		GetPosts    func(childComplexity int, owner models.OwnerInput, ids []string, limit *int32, offset *int32) int
	}

	Span struct {
		Key   func(childComplexity int) int
		Marks func(childComplexity int) int
		Text  func(childComplexity int) int
		Type  func(childComplexity int) int
	}

	User struct {
		FullName        func(childComplexity int) int
		ID              func(childComplexity int) int
		ProfileImageURL func(childComplexity int) int
		Username        func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "ACL.canComment":
		if e.complexity.ACL.CanComment == nil {
			break
		}

		return e.complexity.ACL.CanComment(childComplexity), true

	case "ACL.canLike":
		if e.complexity.ACL.CanLike == nil {
			break
		}

		return e.complexity.ACL.CanLike(childComplexity), true

	case "ACL.canReply":
		if e.complexity.ACL.CanReply == nil {
			break
		}

		return e.complexity.ACL.CanReply(childComplexity), true

	case "ACL.canShare":
		if e.complexity.ACL.CanShare == nil {
			break
		}

		return e.complexity.ACL.CanShare(childComplexity), true

	case "ACL.canView":
		if e.complexity.ACL.CanView == nil {
			break
		}

		return e.complexity.ACL.CanView(childComplexity), true

	case "BlockBlock.children":
		if e.complexity.BlockBlock.Children == nil {
			break
		}

		return e.complexity.BlockBlock.Children(childComplexity), true

	case "BlockBlock._key":
		if e.complexity.BlockBlock.Key == nil {
			break
		}

		return e.complexity.BlockBlock.Key(childComplexity), true

	case "BlockBlock.level":
		if e.complexity.BlockBlock.Level == nil {
			break
		}

		return e.complexity.BlockBlock.Level(childComplexity), true

	case "BlockBlock.listItem":
		if e.complexity.BlockBlock.ListItem == nil {
			break
		}

		return e.complexity.BlockBlock.ListItem(childComplexity), true

	case "BlockBlock.markDefs":
		if e.complexity.BlockBlock.MarkDefs == nil {
			break
		}

		return e.complexity.BlockBlock.MarkDefs(childComplexity), true

	case "BlockBlock.style":
		if e.complexity.BlockBlock.Style == nil {
			break
		}

		return e.complexity.BlockBlock.Style(childComplexity), true

	case "BlockBlock._type":
		if e.complexity.BlockBlock.Type == nil {
			break
		}

		return e.complexity.BlockBlock.Type(childComplexity), true

	case "Blocks.block":
		if e.complexity.Blocks.Block == nil {
			break
		}

		return e.complexity.Blocks.Block(childComplexity), true

	case "Blocks.break":
		if e.complexity.Blocks.Break == nil {
			break
		}

		return e.complexity.Blocks.Break(childComplexity), true

	case "Blocks.image":
		if e.complexity.Blocks.Image == nil {
			break
		}

		return e.complexity.Blocks.Image(childComplexity), true

	case "BreakBlock._key":
		if e.complexity.BreakBlock.Key == nil {
			break
		}

		return e.complexity.BreakBlock.Key(childComplexity), true

	case "BreakBlock._type":
		if e.complexity.BreakBlock.Type == nil {
			break
		}

		return e.complexity.BreakBlock.Type(childComplexity), true

	case "Channel.bannerImageUrl":
		if e.complexity.Channel.BannerImageURL == nil {
			break
		}

		return e.complexity.Channel.BannerImageURL(childComplexity), true

	case "Channel.createdAt":
		if e.complexity.Channel.CreatedAt == nil {
			break
		}

		return e.complexity.Channel.CreatedAt(childComplexity), true

	case "Channel.description":
		if e.complexity.Channel.Description == nil {
			break
		}

		return e.complexity.Channel.Description(childComplexity), true

	case "Channel.followersCount":
		if e.complexity.Channel.FollowersCount == nil {
			break
		}

		return e.complexity.Channel.FollowersCount(childComplexity), true

	case "Channel.id":
		if e.complexity.Channel.ID == nil {
			break
		}

		return e.complexity.Channel.ID(childComplexity), true

	case "Channel.isFollower":
		if e.complexity.Channel.IsFollower == nil {
			break
		}

		return e.complexity.Channel.IsFollower(childComplexity), true

	case "Channel.isMember":
		if e.complexity.Channel.IsMember == nil {
			break
		}

		return e.complexity.Channel.IsMember(childComplexity), true

	case "Channel.membersCount":
		if e.complexity.Channel.MembersCount == nil {
			break
		}

		return e.complexity.Channel.MembersCount(childComplexity), true

	case "Channel.name":
		if e.complexity.Channel.Name == nil {
			break
		}

		return e.complexity.Channel.Name(childComplexity), true

	case "Channel.owner":
		if e.complexity.Channel.Owner == nil {
			break
		}

		return e.complexity.Channel.Owner(childComplexity), true

	case "Channel.posts":
		if e.complexity.Channel.Posts == nil {
			break
		}

		return e.complexity.Channel.Posts(childComplexity), true

	case "Channel.profileImageUrl":
		if e.complexity.Channel.ProfileImageURL == nil {
			break
		}

		return e.complexity.Channel.ProfileImageURL(childComplexity), true

	case "Channel.thumbnailUrl":
		if e.complexity.Channel.ThumbnailURL == nil {
			break
		}

		return e.complexity.Channel.ThumbnailURL(childComplexity), true

	case "Channel.totalPosts":
		if e.complexity.Channel.TotalPosts == nil {
			break
		}

		return e.complexity.Channel.TotalPosts(childComplexity), true

	case "Channel.updatedAt":
		if e.complexity.Channel.UpdatedAt == nil {
			break
		}

		return e.complexity.Channel.UpdatedAt(childComplexity), true

	case "Comment.allowedUserIds":
		if e.complexity.Comment.AllowedUserIds == nil {
			break
		}

		return e.complexity.Comment.AllowedUserIds(childComplexity), true

	case "Comment.author":
		if e.complexity.Comment.Author == nil {
			break
		}

		return e.complexity.Comment.Author(childComplexity), true

	case "Comment.authorId":
		if e.complexity.Comment.AuthorID == nil {
			break
		}

		return e.complexity.Comment.AuthorID(childComplexity), true

	case "Comment.content":
		if e.complexity.Comment.Content == nil {
			break
		}

		return e.complexity.Comment.Content(childComplexity), true

	case "Comment.createdAt":
		if e.complexity.Comment.CreatedAt == nil {
			break
		}

		return e.complexity.Comment.CreatedAt(childComplexity), true

	case "Comment.deletedAt":
		if e.complexity.Comment.DeletedAt == nil {
			break
		}

		return e.complexity.Comment.DeletedAt(childComplexity), true

	case "Comment.deniedUserIds":
		if e.complexity.Comment.DeniedUserIds == nil {
			break
		}

		return e.complexity.Comment.DeniedUserIds(childComplexity), true

	case "Comment.edited":
		if e.complexity.Comment.Edited == nil {
			break
		}

		return e.complexity.Comment.Edited(childComplexity), true

	case "Comment._id":
		if e.complexity.Comment.ID == nil {
			break
		}

		return e.complexity.Comment.ID(childComplexity), true

	case "Comment.meta":
		if e.complexity.Comment.Meta == nil {
			break
		}

		return e.complexity.Comment.Meta(childComplexity), true

	case "Comment.parentId":
		if e.complexity.Comment.ParentID == nil {
			break
		}

		return e.complexity.Comment.ParentID(childComplexity), true

	case "Comment.personalizedMeta":
		if e.complexity.Comment.PersonalizedMeta == nil {
			break
		}

		return e.complexity.Comment.PersonalizedMeta(childComplexity), true

	case "Comment.privacy":
		if e.complexity.Comment.Privacy == nil {
			break
		}

		return e.complexity.Comment.Privacy(childComplexity), true

	case "Comment.rawContent":
		if e.complexity.Comment.RawContent == nil {
			break
		}

		return e.complexity.Comment.RawContent(childComplexity), true

	case "Comment.tags":
		if e.complexity.Comment.Tags == nil {
			break
		}

		return e.complexity.Comment.Tags(childComplexity), true

	case "Comment.type":
		if e.complexity.Comment.Type == nil {
			break
		}

		return e.complexity.Comment.Type(childComplexity), true

	case "Comment.updatedAt":
		if e.complexity.Comment.UpdatedAt == nil {
			break
		}

		return e.complexity.Comment.UpdatedAt(childComplexity), true

	case "CommentMarkDef._key":
		if e.complexity.CommentMarkDef.Key == nil {
			break
		}

		return e.complexity.CommentMarkDef.Key(childComplexity), true

	case "CommentMarkDef.text":
		if e.complexity.CommentMarkDef.Text == nil {
			break
		}

		return e.complexity.CommentMarkDef.Text(childComplexity), true

	case "CommentMarkDef._type":
		if e.complexity.CommentMarkDef.Type == nil {
			break
		}

		return e.complexity.CommentMarkDef.Type(childComplexity), true

	case "ImageBlock.alt":
		if e.complexity.ImageBlock.Alt == nil {
			break
		}

		return e.complexity.ImageBlock.Alt(childComplexity), true

	case "ImageBlock.caption":
		if e.complexity.ImageBlock.Caption == nil {
			break
		}

		return e.complexity.ImageBlock.Caption(childComplexity), true

	case "ImageBlock.height":
		if e.complexity.ImageBlock.Height == nil {
			break
		}

		return e.complexity.ImageBlock.Height(childComplexity), true

	case "ImageBlock._key":
		if e.complexity.ImageBlock.Key == nil {
			break
		}

		return e.complexity.ImageBlock.Key(childComplexity), true

	case "ImageBlock.src":
		if e.complexity.ImageBlock.Src == nil {
			break
		}

		return e.complexity.ImageBlock.Src(childComplexity), true

	case "ImageBlock._type":
		if e.complexity.ImageBlock.Type == nil {
			break
		}

		return e.complexity.ImageBlock.Type(childComplexity), true

	case "ImageBlock.width":
		if e.complexity.ImageBlock.Width == nil {
			break
		}

		return e.complexity.ImageBlock.Width(childComplexity), true

	case "LinkMarkDef.href":
		if e.complexity.LinkMarkDef.Href == nil {
			break
		}

		return e.complexity.LinkMarkDef.Href(childComplexity), true

	case "LinkMarkDef._key":
		if e.complexity.LinkMarkDef.Key == nil {
			break
		}

		return e.complexity.LinkMarkDef.Key(childComplexity), true

	case "LinkMarkDef.title":
		if e.complexity.LinkMarkDef.Title == nil {
			break
		}

		return e.complexity.LinkMarkDef.Title(childComplexity), true

	case "LinkMarkDef._type":
		if e.complexity.LinkMarkDef.Type == nil {
			break
		}

		return e.complexity.LinkMarkDef.Type(childComplexity), true

	case "MarkDefs.comment":
		if e.complexity.MarkDefs.Comment == nil {
			break
		}

		return e.complexity.MarkDefs.Comment(childComplexity), true

	case "MarkDefs.link":
		if e.complexity.MarkDefs.Link == nil {
			break
		}

		return e.complexity.MarkDefs.Link(childComplexity), true

	case "Media.type":
		if e.complexity.Media.Type == nil {
			break
		}

		return e.complexity.Media.Type(childComplexity), true

	case "Media.url":
		if e.complexity.Media.URL == nil {
			break
		}

		return e.complexity.Media.URL(childComplexity), true

	case "Meta.commentsCount":
		if e.complexity.Meta.CommentsCount == nil {
			break
		}

		return e.complexity.Meta.CommentsCount(childComplexity), true

	case "Meta.likesCount":
		if e.complexity.Meta.LikesCount == nil {
			break
		}

		return e.complexity.Meta.LikesCount(childComplexity), true

	case "Meta.sharesCount":
		if e.complexity.Meta.SharesCount == nil {
			break
		}

		return e.complexity.Meta.SharesCount(childComplexity), true

	case "Meta.viewsCount":
		if e.complexity.Meta.ViewsCount == nil {
			break
		}

		return e.complexity.Meta.ViewsCount(childComplexity), true

	case "Mutation.createComment":
		if e.complexity.Mutation.CreateComment == nil {
			break
		}

		args, err := ec.field_Mutation_createComment_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateComment(childComplexity, args["input"].(models.CommentInput)), true

	case "Mutation.createLike":
		if e.complexity.Mutation.CreateLike == nil {
			break
		}

		args, err := ec.field_Mutation_createLike_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateLike(childComplexity, args["input"].(models.LikeInput)), true

	case "Mutation.createPost":
		if e.complexity.Mutation.CreatePost == nil {
			break
		}

		args, err := ec.field_Mutation_createPost_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePost(childComplexity, args["input"].(models.PostInput)), true

	case "Mutation.deleteComment":
		if e.complexity.Mutation.DeleteComment == nil {
			break
		}

		args, err := ec.field_Mutation_deleteComment_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteComment(childComplexity, args["id"].(string), args["owner"].(models.OwnerInput)), true

	case "Mutation.deletePost":
		if e.complexity.Mutation.DeletePost == nil {
			break
		}

		args, err := ec.field_Mutation_deletePost_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePost(childComplexity, args["id"].(string), args["owner"].(models.OwnerInput)), true

	case "Mutation.deleteReply":
		if e.complexity.Mutation.DeleteReply == nil {
			break
		}

		args, err := ec.field_Mutation_deleteReply_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteReply(childComplexity, args["id"].(string), args["owner"].(models.OwnerInput)), true

	case "Owner.id":
		if e.complexity.Owner.ID == nil {
			break
		}

		return e.complexity.Owner.ID(childComplexity), true

	case "Owner.type":
		if e.complexity.Owner.Type == nil {
			break
		}

		return e.complexity.Owner.Type(childComplexity), true

	case "PersonalizedMeta.acl":
		if e.complexity.PersonalizedMeta.ACL == nil {
			break
		}

		return e.complexity.PersonalizedMeta.ACL(childComplexity), true

	case "PersonalizedMeta.likedByUser":
		if e.complexity.PersonalizedMeta.LikedByUser == nil {
			break
		}

		return e.complexity.PersonalizedMeta.LikedByUser(childComplexity), true

	case "PersonalizedMeta.sharedByUser":
		if e.complexity.PersonalizedMeta.SharedByUser == nil {
			break
		}

		return e.complexity.PersonalizedMeta.SharedByUser(childComplexity), true

	case "PersonalizedMeta.viewedByUser":
		if e.complexity.PersonalizedMeta.ViewedByUser == nil {
			break
		}

		return e.complexity.PersonalizedMeta.ViewedByUser(childComplexity), true

	case "PortableText.blocks":
		if e.complexity.PortableText.Blocks == nil {
			break
		}

		return e.complexity.PortableText.Blocks(childComplexity), true

	case "Post.allowedUserIds":
		if e.complexity.Post.AllowedUserIds == nil {
			break
		}

		return e.complexity.Post.AllowedUserIds(childComplexity), true

	case "Post.author":
		if e.complexity.Post.Author == nil {
			break
		}

		return e.complexity.Post.Author(childComplexity), true

	case "Post.authorId":
		if e.complexity.Post.AuthorID == nil {
			break
		}

		return e.complexity.Post.AuthorID(childComplexity), true

	case "Post.content":
		if e.complexity.Post.Content == nil {
			break
		}

		return e.complexity.Post.Content(childComplexity), true

	case "Post.createdAt":
		if e.complexity.Post.CreatedAt == nil {
			break
		}

		return e.complexity.Post.CreatedAt(childComplexity), true

	case "Post.deletedAt":
		if e.complexity.Post.DeletedAt == nil {
			break
		}

		return e.complexity.Post.DeletedAt(childComplexity), true

	case "Post.deniedUserIds":
		if e.complexity.Post.DeniedUserIds == nil {
			break
		}

		return e.complexity.Post.DeniedUserIds(childComplexity), true

	case "Post.edited":
		if e.complexity.Post.Edited == nil {
			break
		}

		return e.complexity.Post.Edited(childComplexity), true

	case "Post._id":
		if e.complexity.Post.ID == nil {
			break
		}

		return e.complexity.Post.ID(childComplexity), true

	case "Post.meta":
		if e.complexity.Post.Meta == nil {
			break
		}

		return e.complexity.Post.Meta(childComplexity), true

	case "Post.owner":
		if e.complexity.Post.Owner == nil {
			break
		}

		return e.complexity.Post.Owner(childComplexity), true

	case "Post.personalizedMeta":
		if e.complexity.Post.PersonalizedMeta == nil {
			break
		}

		return e.complexity.Post.PersonalizedMeta(childComplexity), true

	case "Post.privacy":
		if e.complexity.Post.Privacy == nil {
			break
		}

		return e.complexity.Post.Privacy(childComplexity), true

	case "Post.rawContent":
		if e.complexity.Post.RawContent == nil {
			break
		}

		return e.complexity.Post.RawContent(childComplexity), true

	case "Post.tags":
		if e.complexity.Post.Tags == nil {
			break
		}

		return e.complexity.Post.Tags(childComplexity), true

	case "Post.type":
		if e.complexity.Post.Type == nil {
			break
		}

		return e.complexity.Post.Type(childComplexity), true

	case "Post.updatedAt":
		if e.complexity.Post.UpdatedAt == nil {
			break
		}

		return e.complexity.Post.UpdatedAt(childComplexity), true

	case "PostGenericDocument.allowedUserIds":
		if e.complexity.PostGenericDocument.AllowedUserIds == nil {
			break
		}

		return e.complexity.PostGenericDocument.AllowedUserIds(childComplexity), true

	case "PostGenericDocument.authorId":
		if e.complexity.PostGenericDocument.AuthorID == nil {
			break
		}

		return e.complexity.PostGenericDocument.AuthorID(childComplexity), true

	case "PostGenericDocument.content":
		if e.complexity.PostGenericDocument.Content == nil {
			break
		}

		return e.complexity.PostGenericDocument.Content(childComplexity), true

	case "PostGenericDocument.createdAt":
		if e.complexity.PostGenericDocument.CreatedAt == nil {
			break
		}

		return e.complexity.PostGenericDocument.CreatedAt(childComplexity), true

	case "PostGenericDocument.deletedAt":
		if e.complexity.PostGenericDocument.DeletedAt == nil {
			break
		}

		return e.complexity.PostGenericDocument.DeletedAt(childComplexity), true

	case "PostGenericDocument.deniedUserIds":
		if e.complexity.PostGenericDocument.DeniedUserIds == nil {
			break
		}

		return e.complexity.PostGenericDocument.DeniedUserIds(childComplexity), true

	case "PostGenericDocument.edited":
		if e.complexity.PostGenericDocument.Edited == nil {
			break
		}

		return e.complexity.PostGenericDocument.Edited(childComplexity), true

	case "PostGenericDocument._id":
		if e.complexity.PostGenericDocument.ID == nil {
			break
		}

		return e.complexity.PostGenericDocument.ID(childComplexity), true

	case "PostGenericDocument.owner":
		if e.complexity.PostGenericDocument.Owner == nil {
			break
		}

		return e.complexity.PostGenericDocument.Owner(childComplexity), true

	case "PostGenericDocument.parentId":
		if e.complexity.PostGenericDocument.ParentID == nil {
			break
		}

		return e.complexity.PostGenericDocument.ParentID(childComplexity), true

	case "PostGenericDocument.privacy":
		if e.complexity.PostGenericDocument.Privacy == nil {
			break
		}

		return e.complexity.PostGenericDocument.Privacy(childComplexity), true

	case "PostGenericDocument.rawContent":
		if e.complexity.PostGenericDocument.RawContent == nil {
			break
		}

		return e.complexity.PostGenericDocument.RawContent(childComplexity), true

	case "PostGenericDocument.tags":
		if e.complexity.PostGenericDocument.Tags == nil {
			break
		}

		return e.complexity.PostGenericDocument.Tags(childComplexity), true

	case "PostGenericDocument.type":
		if e.complexity.PostGenericDocument.Type == nil {
			break
		}

		return e.complexity.PostGenericDocument.Type(childComplexity), true

	case "PostGenericDocument.updatedAt":
		if e.complexity.PostGenericDocument.UpdatedAt == nil {
			break
		}

		return e.complexity.PostGenericDocument.UpdatedAt(childComplexity), true

	case "Query.getChannel":
		if e.complexity.Query.GetChannel == nil {
			break
		}

		args, err := ec.field_Query_getChannel_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetChannel(childComplexity, args["id"].(int64)), true

	case "Query.getComments":
		if e.complexity.Query.GetComments == nil {
			break
		}

		args, err := ec.field_Query_getComments_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetComments(childComplexity, args["parentId"].(string), args["limit"].(*int32), args["offset"].(*int32)), true

	case "Query.getPosts":
		if e.complexity.Query.GetPosts == nil {
			break
		}

		args, err := ec.field_Query_getPosts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetPosts(childComplexity, args["owner"].(models.OwnerInput), args["ids"].([]string), args["limit"].(*int32), args["offset"].(*int32)), true

	case "Span._key":
		if e.complexity.Span.Key == nil {
			break
		}

		return e.complexity.Span.Key(childComplexity), true

	case "Span.marks":
		if e.complexity.Span.Marks == nil {
			break
		}

		return e.complexity.Span.Marks(childComplexity), true

	case "Span.text":
		if e.complexity.Span.Text == nil {
			break
		}

		return e.complexity.Span.Text(childComplexity), true

	case "Span._type":
		if e.complexity.Span.Type == nil {
			break
		}

		return e.complexity.Span.Type(childComplexity), true

	case "User.fullName":
		if e.complexity.User.FullName == nil {
			break
		}

		return e.complexity.User.FullName(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.profileImageUrl":
		if e.complexity.User.ProfileImageURL == nil {
			break
		}

		return e.complexity.User.ProfileImageURL(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputBlockBlockInput,
		ec.unmarshalInputBlockInput,
		ec.unmarshalInputBreakBlockInput,
		ec.unmarshalInputCommentInput,
		ec.unmarshalInputCommentMarkDefInput,
		ec.unmarshalInputImageBlockInput,
		ec.unmarshalInputLikeInput,
		ec.unmarshalInputLinkMarkDefInput,
		ec.unmarshalInputMarkDefInput,
		ec.unmarshalInputMediaInput,
		ec.unmarshalInputOwnerInput,
		ec.unmarshalInputPortableTextInput,
		ec.unmarshalInputPostInput,
		ec.unmarshalInputSimpleInput,
		ec.unmarshalInputSpanInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../external/graph/portableText.graphqls", Input: `directive @oneof on INPUT_OBJECT

"""
A span of text inside a block
"""
enum SpanType {
  span
}

type Span {
  _type: SpanType!
  _key: ID!
  text: String!
  marks: [String!]!
}

"""
Mark definitions (annotations) base
"""
interface MarkDef {
  _key: ID!
  _type: MarkDefType!
}

enum MarkDefType {
  link
  comment
}

"""
MarkDef for links
"""
type LinkMarkDef implements MarkDef {
  _key: ID!
  _type: MarkDefType!
  href: String!
  title: String
}

"""
MarkDef for comments
"""
type CommentMarkDef implements MarkDef {
  _key: ID!
  _type: MarkDefType!
  text: String!
}

"""
Union of all possible markDefs
"""
type MarkDefs {
  link: LinkMarkDef
  comment: CommentMarkDef
}

"""
A block of rich text
"""
enum BlockType {
  block
  image
  break
}

enum StyleType {
  normal
  h1
  h2
  h3
  h4
  h5
  h6
  blockquote
}

interface Block {
  _type: BlockType!
  _key: ID!
}

enum ListItemType {
  bullet
  number
}

type BlockBlock implements Block {
  _type: BlockType!
  _key: ID!
  style: StyleType!
  children: [Span!]!
  markDefs: [MarkDefs!]!
  listItem: ListItemType
  level: Int
}

type ImageBlock implements Block {
  _type: BlockType!
  _key: ID!
  src: String!
  alt: String
  caption: String
  width: String # tailwind css classes only, sanitized
  height: String # tailwind css classes only, sanitized
}

type BreakBlock implements Block {
  _type: BlockType!
  _key: ID!
}

"""
Union of all possible blocks
"""
type Blocks {
  block: BlockBlock
  image: ImageBlock
  break: BreakBlock
}

"""
Top-level PortableText document
"""
type PortableText {
  blocks: [Blocks!]!
}

# ===============================
# Inputs
# ===============================

input SpanInput {
  _type: SpanType!
  _key: ID!
  text: String!
  marks: [String!]!
}

input LinkMarkDefInput {
  _key: ID!
  _type: MarkDefType!
  href: String!
  title: String
}

input CommentMarkDefInput {
  _key: ID!
  _type: MarkDefType!
  text: String!
}

"""
Oneof input for markDefs
"""
input MarkDefInput @oneof {
  link: LinkMarkDefInput
  comment: CommentMarkDefInput
}

"""
Block inputs
"""
input BlockBlockInput {
  _type: BlockType!
  _key: ID!
  style: StyleType!
  children: [SpanInput!]!
  markDefs: [MarkDefInput!]!
  listItem: ListItemType
  level: Int
}

input ImageBlockInput {
  _type: BlockType!
  _key: ID!
  src: String!
  alt: String
  caption: String
  width: String
  height: String
}

input BreakBlockInput {
  _type: BlockType!
  _key: ID!
}

"""
Oneof input for blocks
"""
input BlockInput @oneof {
  block: BlockBlockInput
  image: ImageBlockInput
  break: BreakBlockInput
}

input PortableTextInput {
  blocks: [BlockInput!]!
}
`, BuiltIn: false},
	{Name: "../../external/graph/schema.graphqls", Input: `scalar DateTime
scalar Int64
scalar Int32
scalar ObjectId
scalar JSON

enum PostType {
  POST
  COMMENT
  REPLY
}

enum Privacy {
  PUBLIC
  FRIENDS
  PRIVATE
}

enum MediaType {
  IMAGE
  VIDEO
  GIF
}

enum OwnerType {
  USER
  CHANNEL
  PAGE
}

type Media {
  type: MediaType!
  url: String!
}

# Meta information for posts, comments, and replies
# e.g., likesCount, sharesCount, commentsCount, viewsCount
# will be stored in a separate collection and referenced by the post/comment/reply ID
# will be cached in memory for quick access
# post:postId:meta
type Meta {
  likesCount: Int32!
  sharesCount: Int32!
  viewsCount: Int32!
  commentsCount: Int32 # only for posts
}

# Personalized meta information for the current user
# e.g., whether the current user has liked/shared/viewed the post/comment/reply
# will be fetched separately based on the current user context
type PersonalizedMeta {
  likedByUser: Boolean!
  sharedByUser: Boolean!
  viewedByUser: Boolean!
  acl: ACL!
}

type ACL {
  canView: Boolean!
  canComment: Boolean!
  canReply: Boolean!
  canShare: Boolean!
  canLike: Boolean!
}

type Owner {
  type: OwnerType!
  id: Int64! # userId for USER, channelId for CHANNEL, pageId for PAGE
}

input OwnerInput {
  id: Int64!
  type: OwnerType! # e.g. USER, PAGE, GROUP, etc.
}

type User {
  id: Int64!
  username: String!
  fullName: String!
  profileImageUrl: String
}

# Generic object for posts, comments, and replies
type PostGenericDocument {
  _id: ObjectId!
  type: PostType!
  parentId: ObjectId
  authorId: Int64!
  owner: Owner
  content: PortableText
  rawContent: JSON!
  tags: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  edited: Boolean!
  privacy: Privacy!
  deniedUserIds: [Int64!]
  allowedUserIds: [Int64!]
}

type Post {
  _id: ObjectId!
  type: PostType!
  authorId: Int64!
  author: User! # author of the post will be fetched using authorId
  owner: Owner!
  content: PortableText
  rawContent: JSON!
  tags: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  edited: Boolean!
  privacy: Privacy!
  deniedUserIds: [Int64!]!
  allowedUserIds: [Int64!]!
  meta: Meta!
  personalizedMeta: PersonalizedMeta!
}

type Comment {
  _id: ObjectId!
  type: PostType!
  parentId: ObjectId!
  authorId: Int64!
  author: User! # author of the comment will be fetched using authorId
  content: PortableText
  rawContent: JSON!
  tags: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  edited: Boolean!
  deniedUserIds: [Int64!]!
  allowedUserIds: [Int64!]!
  privacy: Privacy!
  meta: Meta!
  personalizedMeta: PersonalizedMeta!
}

input PostInput {
  authorId: Int64!
  content: PortableTextInput!
  tags: [String!]
  owner: OwnerInput!
  privacy: Privacy!
  deniedUserIds: [Int64!]!
  allowedUserIds: [Int64!]!
}

enum SimpleInputType {
  TEXT
  MEDIA
  VOICE
}

input SimpleInput {
  type: SimpleInputType!
  content: String!
}

input CommentInput {
  parentId: ObjectId!
  level: Int32!
  authorId: Int64!
  content: SimpleInput!
  tags: [String!]
  owner: OwnerInput!
  privacy: Privacy!
  deniedUserIds: [Int64!]!
  allowedUserIds: [Int64!]!
}

input LikeInput {
  targetId: ObjectId! # postId, commentId, or replyId
  targetType: PostType!
  owner: OwnerInput!
  liked: Boolean! # true for like, false for unlike
}

# Mutations
type Mutation {
  createPost(input: PostInput!): PostGenericDocument!

  createComment(input: CommentInput!): PostGenericDocument!

  createLike(input: LikeInput!): Boolean!

  deletePost(id: ObjectId!, owner: OwnerInput!): Boolean!

  deleteComment(id: ObjectId!, owner: OwnerInput!): Boolean!

  deleteReply(id: ObjectId!, owner: OwnerInput!): Boolean!
}

# Inputs
input MediaInput {
  type: MediaType!
  url: String!
}

type Channel {
  id: Int64!
  name: String!
  description: String
  bannerImageUrl: String
  thumbnailUrl: String
  profileImageUrl: String
  createdAt: DateTime!
  updatedAt: DateTime!
  posts: [Post!]!
  totalPosts: Int!
  owner: User!
  membersCount: Int
  followersCount: Int
  isMember: Boolean!
  isFollower: Boolean!
}

# Queries
type Query {
  getPosts(
    owner: OwnerInput!
    ids: [ObjectId!]
    limit: Int
    offset: Int
  ): [Post!]!

  getComments(
    parentId: ObjectId!
    limit: Int
    offset: Int
  ): [Comment!]!

  getChannel(id: Int64!): Channel
}

`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
